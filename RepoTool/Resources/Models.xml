<?xml version="1.0"?>
<doc>
    <assembly>
        <name>RepoTool</name>
    </assembly>
    <members>
        <member name="T:RepoTool.Attributes.ServiceLifetimeAttribute">
            <summary>
            An attribute to indicate that the full content of the code must be scanned to answer.
            </summary>
        </member>
        <member name="M:RepoTool.Attributes.ServiceLifetimeAttribute.#ctor(Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Initializes a new instance of the <see cref="T:RepoTool.Attributes.ServiceLifetimeAttribute"/> class.
            </summary>
            <param name="serviceLifetime">The lifetime of the service.</param>
        </member>
        <member name="T:RepoTool.Attributes.ItemChoiceAttribute">
            <summary>
            An attribute to indicate which item to instantiate for a specific choice in a selection.
            </summary>
        </member>
        <member name="M:RepoTool.Attributes.ItemChoiceAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:RepoTool.Attributes.ItemChoiceAttribute"/> class.
            </summary>
            <param name="itemChoice">The model to choose item.</param>
        </member>
        <member name="P:RepoTool.Attributes.ItemChoiceAttribute.ItemChoice">
            <summary>
            Gets the model to choose item.
            </summary>
        </member>
        <member name="T:RepoTool.Attributes.FullContentScanAttribute">
            <summary>
            An attribute to indicate that the full content of the code must be scanned to answer.
            Only applicable to iterable properties, it will be ignored for other types.
            </summary>
        </member>
        <member name="T:RepoTool.Attributes.ToolChoiceAttribute">
            <summary>
            An attribute to indicate which tool to use for a specific selection.
            </summary>
        </member>
        <member name="M:RepoTool.Attributes.ToolChoiceAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:RepoTool.Attributes.ToolChoiceAttribute"/> class.
            </summary>
            <param name="toolChoice">The model to choose tool.</param>
        </member>
        <member name="P:RepoTool.Attributes.ToolChoiceAttribute.ToolChoice">
            <summary>
            Gets the model to choose tool.
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Changelog.EnChangeArea">
            <summary>
            Represents the functional area affected by a change
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.API">
            <summary>
            Changes to API endpoints, controllers, or service interfaces
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.Database">
            <summary>
            Changes to database schema, queries, or data access
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.UI">
            <summary>
            Changes to user interface components or styling
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.Security">
            <summary>
            Changes to authentication or authorization mechanisms
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.Performance">
            <summary>
            Changes to performance optimization or system resources
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.Configuration">
            <summary>
            Changes to configuration or environment settings
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.Documentation">
            <summary>
            Changes to documentation or comments
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.Testing">
            <summary>
            Changes to test cases or testing infrastructure
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.DevOps">
            <summary>
            Changes to build processes, pipeline, or deployment
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.Integration">
            <summary>
            Changes to third-party integrations
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.BusinessLogic">
            <summary>
            Changes to core business logic or domain model
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeArea.Other">
            <summary>
            Changes that don't fit into other categories
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Changelog.EnChangeImportance">
            <summary>
            Represents the importance level of a change
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeImportance.Minor">
            <summary>
            Minor change with minimal impact (formatting, comments, etc.)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeImportance.Normal">
            <summary>
            Normal change with moderate impact (bug fixes, small features)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeImportance.Major">
            <summary>
            Major change with significant impact (new features, breaking changes)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeImportance.Critical">
            <summary>
            Critical change that affects core functionality or security
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Changelog.EnChangePerformanceImpact">
            <summary>
            Represents the performance impact of a change
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangePerformanceImpact.SignificantImprovement">
            <summary>
            Change significantly improves performance
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangePerformanceImpact.MinorImprovement">
            <summary>
            Change moderately improves performance
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangePerformanceImpact.Neutral">
            <summary>
            Change has no measurable impact on performance
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangePerformanceImpact.MinorRegression">
            <summary>
            Change causes minor performance regression
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangePerformanceImpact.SignificantRegression">
            <summary>
            Change causes significant performance regression
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Changelog.EnChangeQuality">
            <summary>
            Represents the quality assessment of a change
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeQuality.VeryPoor">
            <summary>
            Very Poor quality (unacceptable, severe issues)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeQuality.NeedsImprovement">
            <summary>
            Needs improvement (potential issues, incomplete, or not well-implemented)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeQuality.Acceptable">
            <summary>
            Acceptable quality (meets minimum standards but could be better)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeQuality.Good">
            <summary>
            Good quality (well-implemented and meets requirements)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeQuality.Excellent">
            <summary>
            Excellent quality (exceptional implementation, optimized, or innovative)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeQuality.Outstanding">
            <summary>
            Outstanding quality (exceeds expectations, highly innovative, and sets a new standard)
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Changelog.EnChangeSpecialization">
            <summary>
            Represents the specialization area of a change
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeSpecialization.Frontend">
            <summary>
            Changes to frontend code or user interface
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeSpecialization.Backend">
            <summary>
            Changes to backend services or APIs
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeSpecialization.Infrastructure">
            <summary>
            Changes to infrastructure components like servers, databases, or networks
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeSpecialization.QA">
            <summary>
            Changes to quality assurance processes or testing
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeSpecialization.Data">
            <summary>
            Changes to data storage, retrieval, or processing
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeSpecialization.Security">
            <summary>
            Changes to security mechanisms or policies
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeSpecialization.DevOps">
            <summary>
            Changes to development operations or deployment processes
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeSpecialization.Documentation">
            <summary>
            Changes to project documentation
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeSpecialization.CrossFunctional">
            <summary>
            Changes that span multiple specialization areas
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeSpecialization.Other">
            <summary>
            Changes that don't fit into other categories
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Changelog.EnChangeTechDebt">
            <summary>
            Represents the technical debt impact of a change
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeTechDebt.Reduces">
            <summary>
            Change reduces existing technical debt
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeTechDebt.Neutral">
            <summary>
            Change has no significant impact on technical debt
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeTechDebt.Introduces">
            <summary>
            Change introduces some technical debt with justification
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeTechDebt.Significant">
            <summary>
            Change introduces significant technical debt that should be addressed soon
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeTechDebt.Critical">
            <summary>
            Change introduces critical technical debt requiring immediate attention
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Changelog.EnChangeType">
            <summary>
            Represents the type of change
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeType.Feature">
            <summary>
            New feature or functionality
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeType.BugFix">
            <summary>
            Fix for a bug or issue
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeType.Refactor">
            <summary>
            Changes that improve code quality without changing functionality
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeType.Performance">
            <summary>
            Performance improvement changes
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeType.Security">
            <summary>
            Security related changes
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeType.Documentation">
            <summary>
            Changes to documentation
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeType.Dependencies">
            <summary>
            Changes to dependencies or third-party libraries
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeType.Test">
            <summary>
            Changes to tests or testing infrastructure
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeType.Style">
            <summary>
            Visual or user experience changes that don't add functionality
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeType.DevOps">
            <summary>
            Changes to build process, CI/CD, or deployment
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Changelog.EnChangeType.Other">
            <summary>
            Changes that don't fit into other categories
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Inference.EnInferenceProvider">
            <summary>
            Represents the provider to use for inference.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Inference.EnInferenceProvider.Ollama">
            <summary>
            Use Ollama for inference.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Inference.EnInferenceProvider.OpenAi">
            <summary>
            Use OpenAI for inference.
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Inference.EnInferenceReason">
            <summary>
            Represents the reason that inference was called
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Inference.EnInferenceReason.Changelog">
            <summary>
            Determine changelog entries
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Inference.EnInferenceReason.Summarization">
            <summary>
            Summarize content of a collection, file or code
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Inference.EnInferenceReason.Parsing">
            <summary>
            Parse a file into a language-agnostic representation
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Inference.EnInferenceRole">
            <summary>
            Represents the type of message being sent to the inference engine
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Inference.EnInferenceRole.System">
            <summary>
            Represents the system.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Inference.EnInferenceRole.User">
            <summary>
            Represents the user
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Inference.EnInferenceRole.Assistant">
            <summary>
            Represents the assistant.
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Parser.EnCallableModifierFlag">
            <summary>
            Unified flag enum for callable modifiers
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Static">
            <summary>
            Indicates that a callable is static (class-level)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Instance">
            <summary>
            Indicates that a callable is instance (instance-level)
            Indicates whether the callable is a method (associated with a class/object) or a standalone callable.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Async">
            <summary>
            Indicates that a callable is asynchronous
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Generator">
            <summary>
            Indicates that a callable is a generator callable
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Recursive">
            <summary>
            Indicates that a callable is recursive
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Pure">
            <summary>
            Indicates that a callable is pure (no side effects)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.HigherOrder">
            <summary>
            Indicates that a callable is higher-order (accepts or returns callables)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Variadic">
            <summary>
            Indicates that a callable is variadic (accepts variable number of arguments)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Constructor">
            <summary>
            Indicates that a callable is a constructor
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Destructor">
            <summary>
            Indicates that a callable is a destructor/finalizer
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Override">
            <summary>
            Indicates that a callable overrides a base class callable
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Virtual">
            <summary>
            Indicates that a callable can be overridden by derived classes
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Abstract">
            <summary>
            Indicates that a callable is abstract and must be implemented by derived classes
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Sealed">
            <summary>
            Indicates that a callable cannot be overridden by derived classes
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Operator">
            <summary>
            Indicates that a callable is an operator overload
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Extension">
            <summary>
            Indicates that a callable is an extension callable
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Getter">
            <summary>
            Indicates that a callable is a getter
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.Setter">
            <summary>
            Indicates that a callable is a setter
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnCallableModifierFlag.OperatorOverload">
            <summary>
            Indicates that a callable is an operator overload
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnParameterModifierFlag.Optional">
            <summary>
            Indicates that a parameter is optional
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnParameterModifierFlag.Rest">
            <summary>
            Indicates that a parameter is a rest/varargs parameter
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnParameterModifierFlag.ByReference">
            <summary>
            Indicates that a parameter is passed by reference
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnParameterModifierFlag.ByValue">
            <summary>
            Indicates that a parameter is passed by value
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnParameterModifierFlag.Output">
            <summary>
            Indicates that a parameter is an output parameter
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnParameterModifierFlag.HasDefaultValue">
            <summary>
            Indicates that a parameter has a default value
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnParameterModifierFlag.Keyword">
            <summary>
            Indicates that a parameter is a keyword parameter (named parameter)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnParameterModifierFlag.This">
            <summary>
            Indicates that a parameter is 'this' meaning acting on the current variable
            e.g. the instance of the class
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnTypeInfoModifierFlag.Nullable">
            <summary>
            Indicates that the type is nullable
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnTypeInfoModifierFlag.Generic">
            <summary>
            Indicates that the type is generic
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnTypeInfoModifierFlag.Primitive">
            <summary>
            Indicates that the type is a primitive type
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnTypeInfoModifierFlag.Dynamic">
            <summary>
            Indicates that the type is dynamically typed
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnTypeInfoModifierFlag.Pointer">
            <summary>
            Indicates that the type is pointer
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnTypeInfoModifierFlag.Object">
            <summary>
            Indicates that the type is object
            Used for classes, structs, interfaces, enums, delegates, etc.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnTypeInfoModifierFlag.DuckTyped">
            <summary>
            Indicates that the type is duck-typed
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Parser.EnLanguageParadigm">
            <summary>
            Represents the programming paradigm of a language.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnLanguageParadigm.ObjectOriented">
            <summary>
            Object-oriented programming paradigm.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnLanguageParadigm.Functional">
            <summary>
            Functional programming paradigm.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnLanguageParadigm.Procedural">
            <summary>
            Procedural programming paradigm.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnLanguageParadigm.Declarative">
            <summary>
            Declarative programming paradigm.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnLanguageParadigm.Logic">
            <summary>
            Logic programming paradigm.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnLanguageParadigm.Concurrent">
            <summary>
            Concurrent programming paradigm.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnLanguageParadigm.Symbolic">
            <summary>
            Symbolic programming paradigm
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnLanguageParadigm.Data">
            <summary>
            Represents a data paradigm.
            e.g. JSON, YAML etc.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnLanguageParadigm.Other">
            <summary>
            Other less common paradigms.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnClassModifierFlag.Partial">
            <summary>
            Indicates that a class is partial (can be split across multiple files)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnClassModifierFlag.Generic">
            <summary>
            Indicates that a class is generic
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnClassModifierFlag.Interface">
            <summary>
            Indicates that a class is an interface
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnClassModifierFlag.Attribute">
            <summary>
            Indicates that a class is a attribute
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnTypeModifierFlag.Partial">
            <summary>
            Indicates that a class is partial (can be split across multiple files)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnTypeModifierFlag.Unsafe">
            <summary>
            Indicates that type allows unsafe code
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Parser.EnAccessModifierFlag">
            <summary>
            Represents the access modifiers for members.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnAccessModifierFlag.Public">
            <summary>
            Public access modifier.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnAccessModifierFlag.Private">
            <summary>
            Private access modifier.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnAccessModifierFlag.Protected">
            <summary>
            Protected access modifier.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnAccessModifierFlag.Internal">
            <summary>
            Internal access modifier.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnInheritanceModifierFlag.Abstract">
            <summary>
            Indicates that the inheritance is abstract and cannot be instantiated
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnInheritanceModifierFlag.Static">
            <summary>
            Indicates that a item is static and cannot be instantiated
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnInheritanceModifierFlag.Sealed">
            <summary>
            Indicates that a item cannot be inherited from
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnInheritanceModifierFlag.Virtual">
            <summary>
            Indicates that a item is virtual and can be overriden
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnInheritanceModifierFlag.Override">
            <summary>
            Indicates that a item overrides a base item property
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnInheritanceModifierFlag.Extern">
            <summary>
            Indicates that the item is defined in another place
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnInheritanceModifierFlag.New">
            <summary>
            Indicates that a item is new and hides a base item property
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnVariableModifierFlag.Constant">
            <summary>
            Indicates that a variable is constant/final and cannot be changed after initialization
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnVariableModifierFlag.Volatile">
            <summary>
            Indicates that a variable is volatile (can be modified by multiple threads)
            </summary>
        </member>
        <member name="T:RepoTool.Enums.Parser.EnDeclarationModifierFlag">
            <summary>
            Represents the access modifiers for declarations.
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnDeclarationModifierFlag.ReadOnly">
            <summary>
            Indicates that a variable is readonly (can only be set in constructor)
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnPropertyModifierFlag.ReadOnly">
            <summary>
            Indicates that a property is read-only
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnPropertyModifierFlag.HasCustomGetter">
            <summary>
            Indicates that a property has a custom getter
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnPropertyModifierFlag.HasCustomSetter">
            <summary>
            Indicates that a property has a custom setter
            </summary>
        </member>
        <member name="F:RepoTool.Enums.Parser.EnPropertyModifierFlag.AutoProperty">
            <summary>
            Indicates that a property is an auto-property
            i.e. compiler automatically provides the backing field
            </summary>
        </member>
        <member name="T:RepoTool.Extensions.JsonDocumentExtensions">
            <summary>
            Extension methods for <see cref="T:System.Text.Json.JsonDocument"/>.
            </summary>
        </member>
        <member name="M:RepoTool.Extensions.JsonDocumentExtensions.UpdateJsonDocument(System.Text.Json.JsonDocument,System.Object,EnIterableInsertAt)">
            <summary>
            Updates a JsonDocument containing an iterable with addition of the provided object. 
            This version optimizes performance by directly serializing values to JsonNode instead of intermediate strings.
            </summary>
            <param name="document">The JsonDocument to update.</param>
            <param name="item">The object to add to the iterable in the document.</param>
            <param name="insertAt">Specifies where to insert the new item in the iterable.</param>
            <returns>A new JsonDocument with the applied updates.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the root element is not a JSON object or parsing fails.</exception>
        </member>
        <member name="M:RepoTool.Extensions.JsonDocumentExtensions.GetAsJsonArray(System.Text.Json.JsonDocument)">
            <summary>
            Gets the root element of the JsonDocument as a JsonArray.
            This method is useful for scenarios where the root element is expected to be an array.
            </summary>
            <param name="document"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:RepoTool.Extensions.JsonDocumentExtensions.GetAsJsonNode(System.Text.Json.JsonDocument)">
            <summary>
            Gets the root element of the JsonDocument as a JsonNode.
            This method is useful for scenarios where the root element is expected to be a JSON node.
            </summary>
            <param name="document"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:RepoTool.Extensions.JsonDocumentExtensions.UpdateJsonDocument(System.Text.Json.JsonDocument,System.String,System.Text.Json.JsonDocument)">
            <summary>
            Updates a JsonDocument with a single key-value pair. This version optimizes performance
            by directly serializing the value to JsonNode instead of intermediate strings.
            </summary>
            <param name="document">The JsonDocument to update.</param>
            <param name="fieldName">The key of the field to update.</param>
            <param name="value">The value to set for the specified field.</param>
            <returns>A new JsonDocument with the applied update.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the root element is not a JSON object or parsing fails.</exception>
        </member>
        <member name="M:RepoTool.Extensions.JsonDocumentExtensions.UpdateJsonDocument(System.Text.Json.JsonDocument,System.Collections.Generic.Dictionary{System.String,System.Text.Json.JsonDocument})">
            <summary>
            Updates a JsonDocument with the provided key-JsonDocument pairs. This version optimizes performance
            by cloning JsonElements instead of parsing raw text repeatedly.
            </summary>
            <param name="document">The JsonDocument to update.</param>
            <param name="updates">Dictionary of key-JsonDocument pairs to update in the document.</param>
            <returns>A new JsonDocument with the applied updates.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the root element is not a JSON object or parsing fails.</exception>
        </member>
        <member name="T:RepoTool.Extensions.JsonSchemaExtensions">
            <summary>
            Extension methods for <see cref="T:Json.Schema.JsonSchema"/>.
            </summary>
        </member>
        <member name="T:RepoTool.Extensions.ObjectExtensions">
            <summary>
            Extension methods for <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="M:RepoTool.Extensions.ObjectExtensions.ToJson(System.Object)">
            <summary>
            Converts the <see cref="T:System.Object"/> to a JSON string.
            </summary>
            <param name="obj">The object to convert.</param>
            <returns>A JSON string representation of the object.</returns>
        </member>
        <member name="T:RepoTool.Extensions.PropertyInfoExtensions">
            <summary>
            Extension methods for <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
        </member>
        <member name="M:RepoTool.Extensions.PropertyInfoExtensions.GetJsonSpecialFlag(System.Reflection.PropertyInfo)">
            <summary>
            Gets the <see cref="T:RepoTool.Flags.Parser.JsonSpecialFlag"/> for a given property if specific attributes are present.
            This method checks for the presence of <see cref="T:RepoTool.Attributes.FullContentScanAttribute"/> or <see cref="T:Json.Schema.Generation.UniqueItemsAttribute"/>
            and sets the corresponding flags. Returns null if neither attribute is found.
            </summary>
            <param name="propertyInfo">The property information to inspect.</param>
            <returns>A <see cref="T:RepoTool.Flags.Parser.JsonSpecialFlag"/> value if relevant attributes are found; otherwise, null.</returns>
        </member>
        <member name="M:RepoTool.Extensions.ServiceCollectionExtensions.AddOptionModelsWithValidation(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)">
            <summary>
            Scans the calling assembly for classes implementing <see cref="T:IOptionModel"/> and registers them
            with the DI container using the standard AddOptions&lt;T&gt;().Bind(section).ValidateOnStart() pattern.
            Requires Microsoft.Extensions.Options.DataAnnotations package for validation to work effectively with attributes.
            </summary>
            <param name="services">The <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> to add services to.</param>
            <param name="configuration">The <see cref="T:Microsoft.Extensions.Configuration.IConfiguration"/> instance.</param>
            <returns>The <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> so that additional calls can be chained.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the required helper method cannot be found via reflection, or if a model type lacks the required static 'Section' property.</exception>
        </member>
        <member name="M:RepoTool.Extensions.ServiceCollectionExtensions.RegisterAndValidateOption``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfigurationSection)">
            <summary>
            Registers a specific options type using the standard fluent API.
            </summary>
            <typeparam name="T">The options model type, must be a class implementing IOptionModel.</typeparam>
            <param name="services">The service collection.</param>
            <param name="section">The configuration section to bind to.</param>
        </member>
        <member name="T:RepoTool.Extensions.StringExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.String"/> class.
            </summary>
        </member>
        <member name="M:RepoTool.Extensions.StringExtensions.ToSha256Hash(System.String)">
            <summary>
            Computes the SHA256 hash of the string.
            </summary>
            <param name="input">The input string.</param>
            <returns>The lowercase hexadecimal representation of the SHA256 hash.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the input string is null.</exception>
        </member>
        <member name="T:RepoTool.Extensions.TypeExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Type"/> class.
            </summary>
        </member>
        <member name="M:RepoTool.Extensions.TypeExtensions.GetToolSelectorType(System.Type)">
            <summary>
            Recursively searches the inheritance hierarchy and implemented interfaces of a type
            for the <see cref="T:RepoTool.Attributes.ToolChoiceAttribute"/> and returns the associated tool choice type.
            </summary>
            <param name="recordType">The type to start searching from.</param>
            <returns>The <see cref="T:System.Type"/> specified in the <see cref="T:RepoTool.Attributes.ToolChoiceAttribute"/> if found; otherwise, the original <paramref name="recordType"/>.</returns>
        </member>
        <member name="M:RepoTool.Extensions.TypeExtensions.ContainsJsonExclude(System.Type)">
            <summary>
            Determines whether the specified type or any of its generic arguments (recursively)
            are marked with the <see cref="T:Json.Schema.Generation.JsonExcludeAttribute"/>.
            </summary>
            <param name="type">The type to check.</param>
            <returns>
            <c>true</c> if the type, its generic definition, or any of its nested generic types have the
            <see cref="T:Json.Schema.Generation.JsonExcludeAttribute"/>; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:RepoTool.Extensions.TypeExtensions.IsCollectionType(System.Type)">
            <summary>
            Checks if the specified type is a collection type (e.g., List, Array, etc.).
            </summary>
            <param name="type">The type to check.</param>
            <returns><c>true</c> if the type is a collection type; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:RepoTool.Extensions.TypeExtensions.IsDefinedInRepoToolNamespace(System.Type)">
            <summary>
            Checks if the specified type is defined within the "RepoTool" namespace or its sub-namespaces.
            </summary>
            <param name="type">The type to check.</param>
            <returns><c>true</c> if the type's namespace starts with "RepoTool"; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:RepoTool.Flags.Parser.JsonSpecialFlag">
            <summary>
            Defines special flags for JSON schema generation related to properties.
            </summary>
        </member>
        <member name="F:RepoTool.Flags.Parser.JsonSpecialFlag.None">
            <summary>
            Indicates that no special flags are set.
            </summary>
        </member>
        <member name="F:RepoTool.Flags.Parser.JsonSpecialFlag.FullContentScan">
            <summary>
            Property requires checking over the entire content.
            </summary>
        </member>
        <member name="F:RepoTool.Flags.Parser.JsonSpecialFlag.UniqueItems">
            <summary>
            Property must be composed of unique items only.
            </summary>
        </member>
        <member name="T:RepoTool.Helpers.DocumentationHelper">
            <summary>
            Provides helper methods for accessing XML documentation comments using the DocXml library.
            </summary>
        </member>
        <member name="M:RepoTool.Helpers.DocumentationHelper.#ctor">
            <summary>
            Initializes the DocXmlReader with the embedded documentation XML.
            </summary>
            <remarks>
            This method should be called once during application startup or before the first use
            of GetTypeDocumentation. It's designed to load the XML only once for efficiency.
            Consider making this thread-safe if used in a multi-threaded context without guaranteed
            single initialization.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if the embedded documentation resource cannot be loaded or parsed.</exception>
        </member>
        <member name="M:RepoTool.Helpers.DocumentationHelper.GetTypeDocumentation(System.Type,System.Int32)">
            <summary>
            Gets the structured XML documentation for a specific type using the DocXml library.
            </summary>
            <param name="type">The type to get documentation for.</param>
            <param name="derivedTypeDepth">Controls how many levels of derived types to collect. -1 for all levels, 0 for none, positive number for specific depth.</param>
            <returns>A <see cref="T:RepoTool.Models.Documentation.TypeDocumentation"/> object containing the summary, remarks, examples, fields, and properties from the type's XML documentation, or null if documentation is not found or an error occurs.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the input type is null.</exception>
        </member>
        <member name="M:RepoTool.Helpers.DocumentationHelper.GetAllDerivedTypesDocumentation(System.Type,System.Int32)">
            <summary>
            Gets documentation for all types that derive from the specified type with depth control,
            providing both a hierarchical and a flattened list.
            </summary>
            <param name="baseType">The base type to find derived types for.</param>
            <param name="derivedTypeDepth">Controls how many levels of derived types to collect. -1 for all levels, 0 for none, positive number for specific depth.</param>
            <returns>A list containing the flattened list of all derived types.</returns>
        </member>
        <member name="M:RepoTool.Helpers.DocumentationHelper.GetDirectlyDerivedTypes(System.Type)">
            <summary>
            Gets types that directly derive from the specified base type.
            </summary>
            <param name="baseType">The base type to find direct derived types for.</param>
            <returns>A HashSet of types that directly derive from the specified type.</returns>
        </member>
        <member name="M:RepoTool.Helpers.DocumentationHelper.GetMembersDocumentationModel(System.Type,System.Reflection.MemberTypes)">
            <summary>
            Gets documentation for members (Fields or Properties) of a type as a list of MemberDocumentation objects.
            </summary>
        </member>
        <member name="M:RepoTool.Helpers.DocumentationHelper.GetStructMembersDocumentationModel(System.Type)">
            <summary>
            Gets documentation for struct type property members as a list of StructDocumentation objects. 
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:RepoTool.Helpers.DocumentationHelper.GetMemberDocumentationModel(System.Reflection.MemberInfo)">
            <summary>
            Gets the structured XML documentation for a specific member (Field or Property).
            Returns null if the member is not a field or property.
            </summary>
        </member>
        <member name="M:RepoTool.Helpers.DocumentationHelper.GetTypeName(System.Type)">
            <summary>
            Gets the full name of a type, handling potential nested types.
            </summary>
        </member>
        <member name="M:RepoTool.Helpers.DocumentationHelper.GetMemberTypeName(System.Reflection.MemberInfo)">
            <summary>
            Gets the type name for a member (Field or Property).
            </summary>
        </member>
        <member name="M:RepoTool.Helpers.DocumentationHelper.GetTypeInheritance(System.Type)">
            <summary>
            Gets a list of type names that the specified type directly derives from.
            This includes the base class (if not Object) and directly implemented interfaces.
            </summary>
            <param name="type">The type to analyze</param>
            <returns>A list of full type names that the specified type derives from</returns>
        </member>
        <member name="T:RepoTool.Helpers.InferenceHelper">
            <summary>
            Helper class for interacting with the OpenAI API and caching inference results.
            </summary>
        </member>
        <member name="M:RepoTool.Helpers.InferenceHelper.#ctor(RepoTool.Persistence.RepoToolDbContext,RepoTool.Helpers.DocumentationHelper,Microsoft.Extensions.Options.IOptions{InferenceOptions})">
            <summary>
            Initializes a new instance of the <see cref="T:RepoTool.Helpers.InferenceHelper"/> class.
            </summary>
            <param name="dbContext">The database context.</param>
            <param name="documentationHelper">The documentation helper.</param>
            <param name="options">The inference options.</param>
        </member>
        <member name="M:RepoTool.Helpers.InferenceHelper.GetInferenceAsync``2(InferenceRequest{``1})">
            <summary>
            Gets an inference from the inference provider, using the cache if needed.
            </summary>
            <typeparam name="TOutput">The type of the expected schema/response.</typeparam>
            <typeparam name="TContext">The type of the context.</typeparam>
            <param name="inferenceRequest">The inference request.</param>
            <returns>The inference result, either from the cache or the API.</returns>
            <exception cref="T:System.ArgumentException">Thrown when TOutput is a nullable type.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when the API key, model name, or base URL is not set.</exception>
        </member>
        <member name="M:RepoTool.Helpers.InferenceHelper.ParseMessages(System.String)">
            <summary>
            Method to parse raw message strings into a list of ChatMessage objects.
            </summary>
            <param name="rawMessages">The raw message string containing message role tags.</param>
            <returns>A list of chat message objects.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when an unsupported message role is encountered.</exception>
        </member>
        <member name="P:RepoTool.Helpers.InferenceValueWrapper`1.Value">
            <summary>
            Output of a single value.
            </summary>
        </member>
        <member name="T:RepoTool.Helpers.JsonHelper">
            <summary>
            Provides helper methods for JSON serialization, deserialization, and schema generation.
            </summary>
        </member>
        <member name="M:RepoTool.Helpers.JsonHelper.DefaultTransformSchemaNode(Microsoft.Extensions.AI.AIJsonSchemaCreateContext,System.Text.Json.Nodes.JsonNode)">
            <summary>
            Transforms a JSON schema node during creation.
            This is a placeholder implementation that returns the node unchanged.
            </summary>
            <param name="context">The context for schema creation.</param>
            <param name="node">The JSON node to transform.</param>
            <returns>The transformed JSON node.</returns>
        </member>
        <member name="M:RepoTool.Helpers.JsonHelper.SerializeToJson(System.Object)">
            <summary>
            Serializes an object to a JSON string using System.Text.Json.
            </summary>
            <param name="obj">The object to serialize.</param>
            <returns>A JSON string representation of the object.</returns>
        </member>
        <member name="M:RepoTool.Helpers.JsonHelper.GetOrCreateJsonSchemaAsync(System.Type)">
            <summary>
            Gets the JsonSchema object for the specified type, creating and caching it if necessary.
            </summary>
            <param name="type">The type for which to get the schema object.</param>
            <returns>A task representing the asynchronous operation, containing the <see cref="T:Json.Schema.JsonSchema"/> object.</returns>
        </member>
        <member name="M:RepoTool.Helpers.JsonHelper.ComputeTypeHash(System.Type)">
            <summary>
            Computes a SHA256 hash based on the structure of the given type.
            </summary>
            <param name="type">The type to hash.</param>
            <returns>A hexadecimal string representation of the type's hash.</returns>
        </member>
        <member name="M:RepoTool.Helpers.JsonHelper.DeserializeJsonToType(System.String,System.Type)">
            <summary>
            Deserializes a JSON string to an object of the specified type using System.Text.Json.
            </summary>
            <param name="json">The JSON string to deserialize.</param>
            <param name="targetType">The type of the object to deserialize to.</param>
            <returns>The deserialized object, or null if deserialization fails or the JSON represents null.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if deserialization results in null.</exception>
        </member>
        <member name="M:RepoTool.Helpers.JsonHelper.DeserializeJsonToType``1(System.String)">
            <summary>
            Deserializes a JSON string to an object of type T using System.Text.Json
            </summary>
            <typeparam name="T">The type of the object to deserialize to.</typeparam>
            <param name="json">The JSON string to deserialize.</param>
            <returns>The deserialized object.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if deserialization results in null.</exception>
        </member>
        <member name="M:RepoTool.Helpers.JsonHelper.GetItemSchemaHandlingTypeAsync(System.Type)">
            <summary>
            Gets the primary JSON schema value handling type for the specified C# type.
            </summary>
            <param name="type">The C# type.</param>
            <returns>A task representing the asynchronous operation, containing the <see cref="T:RepoTool.Helpers.EnOutputHandlingType"/> representing the root type(s) of the generated JSON schema.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the schema type cannot be determined.</exception>
        </member>
        <member name="M:RepoTool.Helpers.ParserHelper.ParseRecursively(ParserContext)">
            <summary>
            Recursively parses the given type and returns a JsonDocument.
            </summary>
            <param name="parserContext">The parser context.</param>
            <returns>A JsonDocument representing the parsed data.</returns>
            <exception cref="T:System.NotSupportedException">Thrown if the type is not supported.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if the parsing fails.</exception>
            IMPORTANT: First call to this method must be with the root RECORD type (e.g., ParsedData).
        </member>
        <member name="M:RepoTool.Helpers.ParserHelper.ParseToolSelector(ParserContext)">
            <summary>
            Parses the tool selector for the given tool type.
            IMPORTANT: Must add tool item path component before calling this method.
            </summary>
            <param name="parserContext"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:RepoTool.Helpers.ParserHelper.HandleCommonTools``1(ParserContext,``0)">
            <summary>
            Handles common tool calls like scrolling within the parser context.
            </summary>
            <typeparam name="T">The type of the tool call object.</typeparam>
            <param name="parserContext">The current parser context.</param>
            <param name="toolItem">The tool call object.</param>
            <returns>True if the tool call was handled; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if toolCall is null.</exception>
        </member>
        <member name="M:RepoTool.Helpers.ResourceHelper.GetResourceContent(System.String)">
            <summary>
            Gets the content of an embedded resource file.
            </summary>
            <param name="path">The path of the resource file.</param>
            <returns>The content of the resource file, or null if not found.</returns>
        </member>
        <member name="T:RepoTool.Helpers.ToolingHelper">
            <summary>
            Helper class for tool-related operations.
            </summary>
        </member>
        <member name="M:RepoTool.Helpers.ToolingHelper.GetToolPrompt(System.Type)">
            <summary>
            Gets the tool prompt from the XML comment blocks.
            e.g. &lt;summary&gt;, &lt;remarks&gt;, &lt;example&gt; which contains &lt;code&gt; tags. 
            </summary>
            <param name="type">The type to get the tool prompt from.</param>
            <returns>The tool prompt as a string.</returns>
            <exception cref="T:System.Exception">Thrown when an unexpected error occurs.</exception>
        </member>
        <member name="P:RepoTool.Models.Documentation.BaseDocumentation.Summary">
            <summary>
            Summary block documentation for the item. Can be null if not present.
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.BaseDocumentation.Remarks">
            <summary>
            Remarks block documentation for the item. Can be null if not present.
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.BaseDocumentation.Example">
            <summary>
            Example block documentation for the item. Can be null if not present.
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.BaseTypedDocumentation.TypeName">
            <summary>
            Full name of the type, including namespace and generic types.
            </summary>
        </member>
        <member name="T:RepoTool.Models.Documentation.MemberDocumentation">
            <summary>
            Represents the documentation details for a specific member (field or property).
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.MemberDocumentation.Name">
            <summary>
            Name of the member.
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.MemberDocumentation.Value">
            <summary>
            Value of the member. Null if not applicable.
            Applicable to enum values
            </summary>
        </member>
        <member name="T:RepoTool.Models.Documentation.TypeDocumentation">
            <summary>
            Represents the structured XML documentation extracted for a specific type.
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.TypeDocumentation.DerivesFrom">
            <summary>
            List of types that this type derives from.
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.TypeDocumentation.IsAbstract">
            <summary>
            Boolean for whether type is abstract
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.TypeDocumentation.IsInterface">
            <summary>
            Boolean for whether type is an interface
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.TypeDocumentation.Fields">
            <summary>
            List of documentation details for the type's fields.
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.TypeDocumentation.Properties">
            <summary>
            List of documentation details for the type's properties.
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.TypeDocumentation.Generics">
            <summary>
            Generic type parameters for the type, if any.
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.TypeDocumentation.DerivedTypes">
            <summary>
            List of documentation for types that derive from this type.
            This is populated only for abstract classes and interfaces.
            </summary>
        </member>
        <member name="P:RepoTool.Models.Documentation.TypeDocumentation.Structs">
            <summary>
            List of documentation details for the type's properties' structs.
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Change.Description">
            <summary>
            Description of the change
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Change.Reason">
            <summary>
            Reason for the change
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Change.Importance">
            <summary>
            Importance rating of the change as determined by LLM
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Change.Quality">
            <summary>
            Quality rating of the change as determined by LLM
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Change.Area">
            <summary>
            Functional area affected by the change
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Change.Type">
            <summary>
            Type of the change
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Change.Specialization">
            <summary>
            Specialization area of the change
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Change.TechnicalDebt">
            <summary>
            Technical debt rating of the change
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Change.PerformanceImpact">
            <summary>
            Performance impact of the change
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Change.Size">
            <summary>
            Size of a change in a commit, rated against best-practice commit size
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ChangelogEntity.Changes">
            <summary>
            List of changes in a commit
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ChangelogEntity.Description">
            <summary>
            Description of the commit, terms of new features, bug fixes, etc.
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ChangelogEntity.Reason">
            <summary>
            Reason for the commit, terms of new features, bug fixes, etc.
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Common.BaseEntity.Id">
            <summary>
            Unique identifier for entity
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Common.BaseEntity.CreatedAt">
            <summary>
            Date and time when entity was created
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.Common.BaseEntity.LastModifiedAt">
            <summary>
            Date and time when entity was last modified 
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ParsedFileEntity.FilePath">
            <summary>
            Path to the file being parsed.      
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ParsedFileEntity.FileHash">
            <summary>
            Content hash of the file being parsed.
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ParsedFileEntity.LanguageId">
            <summary>
            Language ID of the file being parsed.
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ParsedFileEntity.Language">
            <summary>
            Language entity of the file being parsed.
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ParsedFileEntity.ParsedFile">
            <summary>
            Parsed data of the file.
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ParsedData.FileDocString">
            <summary>
            Top-level docstring of the file being parsed, not attached to any constructs, just the file itself.
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ParsedData.FileLicense">
            <summary>
            Short name of the license if any specified, not attached to any constructs, just the file itself.
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ParsedData.LanguageParadigm">
            <summary>
            Language-specific paradigm (e.g., Object-Oriented, Functional, Procedural).
            Apply all applicable flags for the current file.
            </summary>
        </member>
        <member name="P:RepoTool.Persistence.Entities.ParsedData.Constructs">
            <summary>
            List of constructs in the file.
            </summary>
        </member>
        <member name="T:RepoTool.Persistence.Migrations.Initial">
            <inheritdoc />
        </member>
        <member name="M:RepoTool.Persistence.Migrations.Initial.Up(Microsoft.EntityFrameworkCore.Migrations.MigrationBuilder)">
            <inheritdoc />
        </member>
        <member name="M:RepoTool.Persistence.Migrations.Initial.Down(Microsoft.EntityFrameworkCore.Migrations.MigrationBuilder)">
            <inheritdoc />
        </member>
        <member name="M:RepoTool.Persistence.Migrations.Initial.BuildTargetModel(Microsoft.EntityFrameworkCore.ModelBuilder)">
            <inheritdoc />
        </member>
        <member name="T:RepoTool.Schemas.OllamaOutputSchema">
            <summary>
            Provides functionality to build a JSON Schema that validates output structures for Ollama API responses.
            This schema builder follows known constraints and limitations of the Ollama schema processing.
            NOTE: Ollama's schema-to-grammar conversion has limitations. Unsupported keywords like 'if/then/else',
            'not', and 'uniqueItems' have been removed from this definition to ensure compatibility,
            potentially reducing the strictness of the validation compared to a full Draft 7 schema validator.
            </summary>
        </member>
        <member name="T:RepoTool.Schemas.OllamaOutputSchema.EnOllamaType">
            <summary>
            Enum representing the allowed data types in Ollama output schema.
            </summary>
        </member>
        <member name="F:RepoTool.Schemas.OllamaOutputSchema.EnOllamaType.String">
            <summary>
            Represents a string type.
            </summary>
        </member>
        <member name="F:RepoTool.Schemas.OllamaOutputSchema.EnOllamaType.Number">
            <summary>
            Represents a numeric (floating-point) type.
            </summary>
        </member>
        <member name="F:RepoTool.Schemas.OllamaOutputSchema.EnOllamaType.Integer">
            <summary>
            Represents an integer type.
            </summary>
        </member>
        <member name="F:RepoTool.Schemas.OllamaOutputSchema.EnOllamaType.Boolean">
            <summary>
            Represents a boolean type.
            </summary>
        </member>
        <member name="F:RepoTool.Schemas.OllamaOutputSchema.EnOllamaType.Array">
            <summary>
            Represents an array type.
            </summary>
        </member>
        <member name="F:RepoTool.Schemas.OllamaOutputSchema.EnOllamaType.Object">
            <summary>
            Represents an object type.
            </summary>
        </member>
        <member name="F:RepoTool.Schemas.OllamaOutputSchema.EnOllamaType.Null">
            <summary>
            Represents a null type.
            </summary>
        </member>
        <member name="M:RepoTool.Schemas.OllamaOutputSchema.CreateSchemaBuilder">
            <summary>
            Creates and configures a <see cref="T:Json.Schema.JsonSchemaBuilder"/> for the Ollama schema.
            This builder defines the structure and constraints of the schema following Ollama's requirements.
            </summary>
            <returns>A configured <see cref="T:Json.Schema.JsonSchemaBuilder"/> instance.</returns>
        </member>
        <member name="M:RepoTool.Schemas.OllamaOutputSchema.BuildSchema">
            <summary>
            Builds the JSON Schema that defines and validates the Ollama output structure.
            This schema ensures any provided output conforms to the supported structure and constraints.
            </summary>
            <returns>A <see cref="T:Json.Schema.JsonSchema"/> instance for Ollama output validation.</returns>
        </member>
        <member name="T:EnChangeSize">
            <summary>
            Represents the size of a change in a commit, rated against best-practice commit size
            </summary>
        </member>
        <member name="F:EnChangeSize.Excellent">
            <summary>
            Excellent - Very small, focused change
            </summary>
        </member>
        <member name="F:EnChangeSize.Good">
            <summary>
            Good - Small, well-contained change
            </summary>
        </member>
        <member name="F:EnChangeSize.Acceptable">
            <summary>
            Acceptable - Medium-sized change, but still focused
            </summary>
        </member>
        <member name="F:EnChangeSize.Large">
            <summary>
            Large - Consider refactoring into smaller commits
            </summary>
        </member>
        <member name="F:EnChangeSize.TooLarge">
            <summary>
            TooLarge - This change is too large and should be broken down
            </summary>
        </member>
        <member name="P:ChangelogContext.SourceChanges">
            <summary>
            Model containing original and changed data for a particular path
            </summary>
        </member>
        <member name="P:InferenceContext.ItemPath">
            <summary>
            Item path of the section currently being parsed.
            Null if not applicable i.e. top-level
            </summary>
        </member>
        <member name="P:ActionWindow.Actions">
            <summary>
            The actions performed in order, latest is last.
            </summary>
        </member>
        <member name="P:ActionWindow.Window">
            <summary>
            Currently visible window of actions.
            </summary>
        </member>
        <member name="P:ActionWindow.WindowSize">
            <summary>
            The number of actions to show in the window.
            Must be at least 1 and has a default of 25.
            </summary>
        </member>
        <member name="M:ActionWindow.CalculateWindow">
            <summary>
            Calculates the current window of actions based on the specified window size.
            </summary>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:ActionWindow.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ActionWindow"/> record.
            Validates the WindowSize upon initialization.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if WindowSize is less than 1.</exception>
        </member>
        <member name="M:ActionWindow.ResizeWindow(System.Int32)">
            <summary>
            Resizes the action window to a new size.
            Modifies the current instance.
            </summary>
            <param name="newWindowSize">The new size of the action window.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if newWindowSize is less than 1.</exception>
        </member>
        <member name="M:ActionWindow.AddAction(Action)">
            <summary>
            Adds a new action to the action window.
            </summary>
            <param name="action">The action to add.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if action is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if action is not of type Action.</exception>
        </member>
        <member name="P:Action.IsSuccess">
            <summary>
            Indicates whether the action was successful.
            </summary>
        </member>
        <member name="P:Action.Message">
            <summary>
            The message associated with the action.
            If an error occurred, this will contain the error message.
            Can be null if successful.
            </summary>
        </member>
        <member name="P:Action.ItemPath">
            <summary>
            The item path associated with the action.
            </summary>
        </member>
        <member name="T:CodeWindowData">
            <summary>
            Represents the data for a code window.
            This includes the starting line number and the size of the window.
            The window size must be at least 1.
            The default size is 25.
            The start line is 1-based.
            The window size is 0-based.
            The window size is the number of lines to show below the start line.
            </summary>
        </member>
        <member name="P:CodeWindowData.StartLine">
            <summary>
            The center line number for the code window. Starts from 1.
            </summary>
        </member>
        <member name="P:CodeWindowData.WindowSize">
            <summary>
            The number of lines to show below the start line. 
            Must be at least 1 and has a default of 25.
            </summary>
        </member>
        <member name="T:CodeWindow">
            <summary>
            Represents a view into a file's content, centered around a specific line.
            </summary>
        </member>
        <member name="P:CodeWindow.StashedWindows">
            <summary>
            Stashed code windows for later use.
            </summary>
        </member>
        <member name="P:CodeWindow.FileContent">
            <summary>
            Content of the file being viewed.
            </summary>
        </member>
        <member name="P:CodeWindow.IsFinished">
            <summary>
            Whether the code window is showing the last page of the full content
            </summary>
        </member>
        <member name="P:CodeWindow.WindowContent">
            <summary>
            Gets the content of the code window, calculated based on FileContent, StartLine, and WindowSize.
            Includes line numbers. The window includes WindowSize lines below the StartLine.
            </summary>
        </member>
        <member name="P:CodeWindow.LinesLeft">
            <summary>
            The number of lines left in the file from the current start line.
            </summary>
        </member>
        <member name="M:CodeWindow.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CodeWindow"/> record.
            Validates the WindowSize upon initialization.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if WindowSize is less than 1.</exception>
        </member>
        <member name="M:CodeWindow.ResizeWindow(System.Int32)">
            <summary>
            Resizes the code window to a new size.
            Modifies the current instance.
            </summary>
            <param name="newWindowSize">The new size of the code window.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if newWindowSize is less than 1.</exception>
        </member>
        <member name="M:CodeWindow.ScrollWindow(System.Int32)">
            <summary>
            Advances the code window view by a specified number of lines in-place.
            Modifies the current instance.
            </summary>
            <param name="linesToScroll">The number of lines to advance the window start.</param>
        </member>
        <member name="M:CodeWindow.PageWindow(System.Int32)">
            <summary>
            Advanced the code window view by a page with a specified number of overlapping lines.
            Modifies the current instance.
            </summary>
            <param name="overlapLines">The number of lines to overlap with the previous window.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if overlapLines is less than 0.</exception>
        </member>
        <member name="M:CodeWindow.ResetWindowPosition">
            <summary>
            Resets the code window to the beginning of the file.
            Modifies the current instance.
            </summary>
        </member>
        <member name="M:CodeWindow.CalculateWindowContent(System.String,System.Int32,System.Int32)">
            <summary>
            Calculates the content for a code window as a list of code lines.
            The window starts at the specified start line and includes the specified number of lines.
            </summary>
            <param name="fileContent">The full content of the file.</param>
            <param name="startLine">The starting line number (1-based) for the window.</param>
            <param name="windowSize">The number of lines to include in the window, starting from the start line.</param>
            <returns>A list of <see cref="T:CodeLine"/> objects representing the window content.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if windowSize is less than 10.</exception>
        </member>
        <member name="M:CodeWindow.StashWindow">
            <summary>
            Stashes the current code window for later use.
            </summary>
        </member>
        <member name="M:CodeWindow.PopWindow">
            <summary>
            Pops the stashed code window, restoring it to the current context.
            </summary>
        </member>
        <member name="T:CodeLine">
            <summary>
            Represents a line of code in the code window.
            </summary>
        </member>
        <member name="P:CodeLine.LineNumber">
            <summary>
            The line number of the code line.
            </summary>
        </member>
        <member name="P:CodeLine.Content">
            <summary>
            The content of the code line.
            </summary>
        </member>
        <member name="T:ItemPath">
            <summary>
            Represents a path to an item in the parsed content.
            </summary>
        </member>
        <member name="P:ItemPath.Components">
            <summary>
            The components that make up the item path.
            </summary>
        </member>
        <member name="P:ItemPath.FullPath">
            <summary>
            Convenience to show the full path as a string.
            </summary>
        </member>
        <member name="M:ItemPath.GetLastObjectType">
            <summary>
            Convenience to get the last component object type.
            </summary>
            <returns>Type</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:ItemPath.AddComponent(ItemPathComponent)">
            <summary>
            Adds a tool component to the end of the current path in-place.
            </summary>
            <param name="component"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:ItemPath.RemoveLastComponent">
            <summary>
            Removes the last component from the current path in-place.
            Does nothing if the path is empty.
            </summary>
        </member>
        <member name="M:ItemPath.GetLastComponent">
            <summary>
            Get the last component object.
            </summary>
            <returns>ItemPathComponent?</returns>
        </member>
        <member name="M:ItemPath.GetLastComponent``1">
            <summary>
            Convenience to get the last component for a specific component type.
            </summary>
            <returns>Type</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:ItemPath.GetParentComponent">
            <summary>
            Get the parent component object.
            </summary>
            <returns>ItemPathComponent?</returns>
        </member>
        <member name="M:ItemPath.UpdateCurrentObject(System.Text.Json.JsonDocument)">
            <summary>
            Update current component object.
            </summary>
            <param name="currentObject">The current object to set.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="currentObject"/> is null.</exception>
        </member>
        <member name="P:ItemPathComponent.CurrentObject">
            <summary>
            Represents the current object in the item path.
            Will show partial object when editing.
            </summary>
        </member>
        <member name="P:ItemPathComponent.CurrentObjectJson">
            <summary>
            Represents the current object in the item path as JSON
            Will show partial object when editing.
            </summary>
        </member>
        <member name="T:ItemPathIndexComponent">
            <summary>
            Represents an index in the item path for an iterable
            </summary>
        </member>
        <member name="P:ItemPathIndexComponent.Index">
            <summary>
            The index in the item path.
            </summary>
        </member>
        <member name="T:ItemPathKeyComponent">
            <summary>
            Represents a key in the item path for a mapping
            </summary>
        </member>
        <member name="P:ItemPathKeyComponent.Key">
            <summary>
            The key in the item path.
            </summary>
        </member>
        <member name="T:ItemPathPropertyComponent">
            <summary>
            Represents a property in the item path.
            </summary>
        </member>
        <member name="F:ItemPathPropertyComponent._propertyName">
            <summary>
            Represents the name of the property in the item path.
            </summary>
        </member>
        <member name="P:ItemPathPropertyComponent.PropertyName">
            <summary>
            Represents the name of the property in the item path.
            </summary>
        </member>
        <member name="P:ItemPathPropertyComponent.PropertyInfo">
            <summary>
            Property currently being processed
            </summary>
        </member>
        <member name="P:ItemPathPropertyComponent.JsonSpecialFlag">
            <summary>
            Specifies the special flags associated with the property.
            </summary>
        </member>
        <member name="T:ItemPathToolComponent">
            <summary>
            Represents a tool used in the item path.
            </summary>
        </member>
        <member name="P:ItemPathToolComponent.ToolType">
            <summary>
            Tool output type.
            </summary>
        </member>
        <member name="P:ParserContext.FilePath">
            <summary>
            Path to the file being parsed.      
            </summary>
        </member>
        <member name="P:ParserContext.CodeWindow">
            <summary>
            Content of the code window to be processed.
            </summary>
        </member>
        <member name="P:ParserContext.ActionWindow">
            <summary>
            Log of actions taken during parsing.
            </summary>
        </member>
        <member name="P:SummarizationContext.Content">
            <summary>
            Content to be summarized.
            </summary>
        </member>
        <member name="T:InferenceMessage">
            <summary>
            Represents a message in the inference process.
            </summary>
        </member>
        <member name="P:InferenceMessage.Role">
            <summary>
            Gets or sets the role of the message sender.
            </summary>
        </member>
        <member name="P:InferenceMessage.Content">
            <summary>
            Gets or sets the content of the message.
            </summary>
        </member>
        <member name="T:InferenceRequest`1">
            <summary>
            Request for inference
            </summary>
        </member>
        <member name="P:InferenceRequest`1.Context">
            <summary>
            Context for inference
            </summary>
        </member>
        <member name="M:InferenceRequest`1.GetInferenceReason">
            <summary>
            Gets the inference reason based on the context type.
            </summary>
        </member>
        <member name="P:TemplateData`1.Request">
            <summary>
            The inference request plus context.
            </summary>
        </member>
        <member name="P:TemplateData`1.Documentation">
            <summary>
            Output and related type documentation.
            </summary>
        </member>
        <member name="P:TemplateData`1.Configuration">
            <summary>
            Template configuration.
            </summary>
        </member>
        <member name="T:TemplateConfiguration">
            <summary>
            Configuration for the template.
            e.g. use full file context or window context. etc.
            </summary>
        </member>
        <member name="T:Documentation">
            <summary>
            Documentation for the inference request.
            </summary>
        </member>
        <member name="P:Documentation.JsonSchema">
            <summary>
            The JSON schema to be used for inference.
            </summary>
        </member>
        <member name="P:Documentation.ItemOutput">
            <summary>
            Output type documentation.
            </summary>
        </member>
        <member name="P:Documentation.ToolOutput">
            <summary>
            Tool output type documentation. Null if not using a tool.
            </summary>
        </member>
        <member name="P:Documentation.PropertyInfo">
            <summary>
            Property currently being processed.
            If builder, then this is the property being built.
            Will be null for one-off top-level values like 'string' or 'int'.
            </summary>
        </member>
        <member name="T:CallableBlock">
            <inheritdoc />
        </member>
        <member name="P:CallableBlock.CallableInfo">
            <summary>
            Information about the callable.
            </summary>
        </member>
        <member name="T:EnInheritanceType">
            <summary>
            Defines the possible types of inheritance.
            </summary>
        </member>
        <member name="F:EnInheritanceType.Inherits">
            <summary>
            Represents class inheritance.
            </summary>
        </member>
        <member name="F:EnInheritanceType.Implements">
            <summary>
            Represents interface implementation.
            </summary>
        </member>
        <member name="T:InheritanceInfo">
            <summary>
            Represents information about inheritance for a class or interface.
            </summary>
        </member>
        <member name="P:InheritanceInfo.InheritedName">
            <summary>
            The name of the inherited type.
            </summary>
            <example>
            <code>
            class MyClass : MyBaseClass { }
            </code>
            Would be parsed as:
            <code>
            {
                "InheritedName": "MyBaseClass"
            }
            </code>
            </example>
        </member>
        <member name="P:InheritanceInfo.InheritanceType">
            <summary>
            The type of inheritance (inheritance or implementation).
            </summary>
            <example>
            <code>
            class MyClass : MyBaseClass { }
            </code>
            Would be parsed as:
            <code>
            {
                "InheritanceType": "Inherits"
            }
            </code>
            </example>
        </member>
        <member name="P:InheritanceInfo.InheritsFrom">
            <summary>
            List of inherited types
            </summary>
        </member>
        <member name="P:InheritanceInfo.InheritanceModifiers">
            <summary>
            List of inheritance modifiers.
            </summary>
        </member>
        <member name="T:ClassBlock">
            <inheritdoc />
        </member>
        <member name="P:ClassBlock.Inheritance">
            <summary>
            Classes that this class inherits from or implements in case of interfaces.
            </summary>
            <example>
            <code>
            class MyClass : MyBaseClass, IMyInterface { }
            </code>
            Would be parsed as:
            <code>
            {
                "Inheritance": [
                    {
                        "InheritedName": "MyBaseClass",
                        "InheritanceType": "Inherits"
                    },
                    {
                        "InheritedName": "IMyInterface",
                        "InheritanceType": "Implements"
                    }
                ]
            }
            </code>
            </example>
        </member>
        <member name="P:ClassBlock.ClassModifierFlags">
            <summary>
            List of all applicable modifier flags for this class.
            Apply all applicable flags for the current item.
            </summary>
            <example>
            <code>
            public static class MyClass { }
            </code>
            Would be parsed as:
            <code>
            {
                "ClassModifierFlags": ["Static"]
            }
            </code>
            </example>
        </member>
        <member name="T:BlockConstruct">
            <inheritdoc />
        </member>
        <member name="P:BlockConstruct.BlockType">
            <summary>
            The type of the block.
            </summary>
            <example>
            <code>
            public class MyClass { }
            </code>
            Would be parsed as:
            <code>
            {
                "BlockType": "Class"
            }
            </code>
            </example>
        </member>
        <member name="P:BlockConstruct.AccessModifiers">
            <summary>
            The list of access modifiers for this block.
            </summary>
            <example>
            <code>
            public class MyClass { }
            </code>
            Would be parsed as:
            <code>
            {
                "AccessModifiers": [ "Public" ]
            }
            </code>
            </example>
        </member>
        <member name="P:BlockConstruct.InheritanceModifiers">
            <summary>
            The list of inheritance modifiers for this block.
            </summary>
            <example>
            <code>
            public sealed class MyClass { }
            </code>
            Would be parsed as:
            <code>
            {
                "InheritanceModifiers": ["Sealed"]
            }
            </code>
            </example>
        </member>
        <member name="P:BlockConstruct.TypeModifiers">
            <summary>
            The list of type modifiers for this block.
            </summary>
            <example>
            <code>
            public static class MyClass { }
            </code>
            Would be parsed as:
            <code>
            {
                "TypeModifiers": ["Static"]
            }
            </code>
            </example>
        </member>
        <member name="P:BlockConstruct.Attributes">
            <summary>
            The list of attributes applied to this block.
            </summary>
            <example>
            <code>
            [Serializable]
            public class MyClass { }
            </code>
            Would be parsed as:
            <code>
            {
                "Attributes": [ { "Name": "Serializable", "Arguments": [] } ]
            }
            </code>
            </example>
        </member>
        <member name="P:BlockConstruct.Constructs">
            <summary>
            List of constructs at the current level.
            </summary>
        </member>
        <member name="T:CustomBlock">
            <inheritdoc />
        </member>
        <member name="P:CustomBlock.LogicDescription">
            <summary>
            Description of the logic for/within the statement
            </summary>
            <example>
            <code>
            {
               "LogicDescription": "This code is meant to calculate the sum of two numbers"
            }
            </code>
            </example>
        </member>
        <member name="P:CustomBlock.LogicPurpose">
            <summary>
            Description of what the logic in a for/within is meant to do
            </summary>
            <example>
            <code>
            {
              "LogicPurpose": "This code is meant to calculate the sum of two numbers"
            }
            </code>
            </example>
        </member>
        <member name="T:EnumBlock">
            <inheritdoc />
        </member>
        <member name="P:EnumBlock.Values">
            <summary>
            Values of the enum.
            </summary>
            <example>
            <code>
            enum MyEnum { Value1, Value2 }
            </code>
            Would be parsed as:
            <code>
            {
                "Values": [
                    { "Name": "Value1" },
                    { "Name": "Value2" }
                ]
            }
            </code>
            </example>
        </member>
        <member name="P:EnumBlock.UnderlyingType">
            <summary>
            Underlying type of the enum (if applicable).
            </summary>
            <example>
            <code>
            enum MyEnum : byte { Value1, Value2 }
            </code>
            Would be parsed as:
            <code>
            {
                "UnderlyingType": { "Name": "byte" }
            }
            </code>
            </example>
        </member>
        <member name="T:EnumValueDefinition">
            <summary>
            Represents a definition of an enum value.
            </summary>
        </member>
        <member name="P:EnumValueDefinition.ValueExpression">
            <summary>
            Literal value of the enum or expression for the enum value.
            Fill in explicit value for implicit enum values.
            </summary>
        </member>
        <member name="P:EnumValueDefinition.Attributes">
            <summary>
            Attributes for this enum value
            </summary>
        </member>
        <member name="T:InterfaceBlock">
            <inheritdoc />
        </member>
        <member name="T:NamespaceBlock">
            <inheritdoc />
        </member>
        <member name="P:NamespaceBlock.FullyQualifiedPath">
            <summary>
            Fully qualified name of the namespace
            e.g. MyApp.MyNamespace.InnerNamespace would be ["MyApp", "MyNamespace", "InnerNamespace"]
            </summary>
            <example>
            <code>
            namespace MyApp.MyNamespace { }
            </code>
            Would be parsed as:
            <code>
            {
                "FullyQualifiedPath": ["MyApp", "MyNamespace"]
            }
            </code>
            </example>
        </member>
        <member name="T:RecordBlock">
            <inheritdoc />
        </member>
        <member name="T:EnStructModifierFlag">
            <summary>
            Defines the possible modifier flags for a struct.
            </summary>
        </member>
        <member name="F:EnStructModifierFlag.Union">
            <summary>
            Indicates that the struct represents a union.
            </summary>
        </member>
        <member name="T:StructBlock">
            <inheritdoc />
        </member>
        <member name="P:StructBlock.StructModifierFlags">
            <summary>
            List of all applicable modifier flags for this struct.
            </summary>
            <example>
            <code>
            public union MyUnion { ... }
            </code>
            Would be parsed as:
            <code>
            {
                "StructModifierFlags": ["Union"]
            }
            </code>
            </example>
        </member>
        <member name="T:EnAttributeTarget">
            <summary>
            Defines the possible targets for an attribute.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Assembly">
            <summary>
            The attribute target is an assembly.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Module">
            <summary>
            The attribute target is a module.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Class">
            <summary>
            The attribute target is a class.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Struct">
            <summary>
            The attribute target is a struct.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Enum">
            <summary>
            The attribute target is an enum.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Constructor">
            <summary>
            The attribute target is a constructor.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Callable">
            <summary>
            The attribute target is a callable (method, function, etc.).
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Property">
            <summary>
            The attribute target is a property.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Field">
            <summary>
            The attribute target is a field.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Event">
            <summary>
            The attribute target is an event.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Interface">
            <summary>
            The attribute target is an interface.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Parameter">
            <summary>
            The attribute target is a parameter.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.Delegate">
            <summary>
            The attribute target is a delegate.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.ReturnValue">
            <summary>
            The attribute target is a return value.
            </summary>
        </member>
        <member name="F:EnAttributeTarget.GenericParameter">
            <summary>
            The attribute target is a generic parameter.
            </summary>
        </member>
        <member name="T:AttributeDefinition">
            <summary>
            Represents the definition of an attribute.
            </summary>
        </member>
        <member name="P:AttributeDefinition.AttributeTarget">
            <summary>
            The target of the attribute.
            </summary>
        </member>
        <member name="P:AttributeDefinition.Attribute">
            <summary>
            The attribute usage expression.
            </summary>
        </member>
        <member name="T:CallableInfoDefinition">
            <summary>
            Represents information about a callable, such as a method or function.
            </summary>
        </member>
        <member name="P:CallableInfoDefinition.Parameters">
            <summary>
            Parameters for the callable.
            </summary>
        </member>
        <member name="P:CallableInfoDefinition.ReturnType">
            <summary>
            Return type of the callable.
            It could be void in which case it would be null.
            </summary>
        </member>
        <member name="P:CallableInfoDefinition.GenericParameters">
            <summary>
            Generic parameters for the callable.
            </summary>
        </member>
        <member name="P:CallableInfoDefinition.CallableModifierFlags">
            <summary>
            List of all applicable modifier flags for this callable.
            Apply all applicable flags for the current item.
            </summary>
            <example>
            <code>
            static void MyMethod()
            </code>
            Would be parsed as:
            <code>
            {
                "CallableModifierFlags": ["Static"]
            }
            </code>
            </example>
        </member>
        <member name="T:EnConstructItemType">
            <summary>
            Defines the possible types of code constructs.
            </summary>
        </member>
        <member name="F:EnConstructItemType.Block">
            <summary>
            Represents a block of code.
            </summary>
        </member>
        <member name="F:EnConstructItemType.Statement">
            <summary>
            Represents a statement.
            </summary>
        </member>
        <member name="F:EnConstructItemType.Declaration">
            <summary>
            Represents a declaration.
            </summary>
        </member>
        <member name="F:EnConstructItemType.Expression">
            <summary>
            Represents an expression.
            </summary>
        </member>
        <member name="F:EnConstructItemType.Directive">
            <summary>
            Represents a preprocessor directive.
            </summary>
        </member>
        <member name="F:EnConstructItemType.Custom">
            <summary>
            Represents a custom construct.
            </summary>
        </member>
        <member name="T:Construct">
            <summary>
            Represents a base construct in the code.
            </summary>
        </member>
        <member name="P:Construct.DocString">
            <summary>
            Top-level docstring for the item if applicable.
            </summary>
        </member>
        <member name="P:Construct.Comment">
            <summary>
            More specific comment for the item if applicable.
            </summary>
        </member>
        <member name="P:Construct.LineNumber">
            <summary>
            Line number of the item start.
            </summary>
        </member>
        <member name="P:Construct.Purpose">
            <summary>
            Purpose of the definition.
            </summary>
        </member>
        <member name="P:Construct.ItemType">
            <summary>
            The type of the item.
            </summary>
        </member>
        <member name="T:NamedConstruct">
            <inheritdoc />
            <summary>
            Represents a construct that has a name.
            </summary>
        </member>
        <member name="P:NamedConstruct.Name">
            <summary>
            Name of the item.
            </summary>
            <example>
            <code>
            int myVariable;
            </code>
            Would be parsed as:
            <code>
            {
                "Name": "myVariable"
            }
            </code>
            </example>
        </member>
        <member name="T:ParameterDefinition">
            <summary>
            Represents the definition of a parameter in a callable.
            </summary>
        </member>
        <member name="P:ParameterDefinition.Type">
            <summary>
            Type of the parameter.
            </summary>
        </member>
        <member name="P:ParameterDefinition.ParameterModifierFlags">
            <summary>
            List of all applicable modifier flags for this parameter.
            Apply all applicable flags for the current item.
            </summary>
            <example>
            <code>
            void MyMethod(ref int x)
            </code>
            Would be parsed as:
            <code>
            {
                "ParameterModifierFlags": ["ByReference"]
            }
            </code>
            </example>
        </member>
        <member name="P:ParameterDefinition.DefaultValue">
            <summary>
            Default value for optional parameter by expression, if applicable.
            </summary>
        </member>
        <member name="T:TypeInfoDefinition">
            <summary>
            Represents information about a type definition.
            - Handles generics and generic constraints
            - Works with wrapped types like lists, dictionaries, etc.
            </summary>
        </member>
        <member name="P:TypeInfoDefinition.Type">
            <summary>
            The type itself.
            </summary>
            <example>
            <code>
            List&lt;string&gt;
            </code>
            Would be parsed as:
            <code>
            {
                "Type": { "TypeName": "List" }
            }
            </code>
            </example>
        </member>
        <member name="P:TypeInfoDefinition.InnerComponents">
            <summary>
            The types that this type contains.
            E.g. for a List&lt;int&gt;, the component is int.
            Do not include current level of type itself in the components list.
            </summary>
            <example>
            <code>
            List&lt;string&gt;
            </code>
            Would be parsed as:
            <code>
            {
                "InnerComponents": [ { "TypeName": "string" } ]
            }
            </code>
            </example>
        </member>
        <member name="T:TypeInfoComponent">
            <summary>
            Represents a component of a type definition.
            </summary>
        </member>
        <member name="P:TypeInfoComponent.TypeName">
            <summary>
            The type name, e.g. int, string, List, Dictionary etc.
            It could be a user-defined type like MyType.
            More complex ones like Dict&lt;string, int&gt; when built from collections.
            It could also be TEntity or TKey, TValue etc. for generics.
            It could also be null for duck-typed languages.
            </summary>
            <example>
            <code>
            List&lt;string&gt;
            </code>
            Would have "TypeName": "List" for the outer component.
            </example>
        </member>
        <member name="P:TypeInfoComponent.FullyQualifiedPath">
            <summary>
            Fully qualified name of the type in its namespace or where it was imported
            e.g. MyNamespace.MyClass.MyStruct.MyType would be ["MyNamespace", "MyClass", "MyStruct"]
            e.g. System.Collections.Generic.List&lt;int&gt; would be ["System", "Collections", "Generic"]
            Primitive types do not have a fully qualified name so those would be null.
            </summary>
            <example>
            <code>
            System.Collections.Generic.List&lt;string&gt;
            </code>
            Would be parsed as:
            <code>
            {
               "FullyQualifiedPath": ["System", "Collections", "Generic"]
            }
            </code>
            </example>
        </member>
        <member name="P:TypeInfoComponent.ModifierFlags">
            <summary>
            List of all applicable modifier flags for this type.
            Apply all applicable flags for the current item.
            </summary>
            <example>
            <code>
            int?
            </code>
            Would be parsed as:
            <code>
            {
              "ModifierFlags": ["Nullable"]
            }
            </code>
            </example>
        </member>
        <member name="P:TypeInfoComponent.Constraints">
            <summary>
            Generic constraint information.
            </summary>
            <example>
            <code>
            where T : class
            </code>
            Would be parsed as:
            <code>
            {
              "Constraints": [{ "ConstraintFlags": "IsReferenceTypeKind" }]
            }
            </code>
            </example>
        </member>
        <member name="P:TypeInfoComponent.GenericArguments">
            <summary>
            Generic type arguments.
            </summary>
            <example>
            <code>
            List&lt;string&gt;
            </code>
            Would be parsed as:
            <code>
            {
              "GenericArguments": [ { "Type": { "TypeName": "string" } } ]
            }
            </code>
            </example>
        </member>
        <member name="T:GenericConstraintInfo">
            <summary>
            Represents information about generic constraints.
            </summary>
        </member>
        <member name="P:GenericConstraintInfo.Name">
            <summary>
            Name accompanying constraint flag
            e.g. which class to inherit from for Inherits constraint
            or which value/reference type to use for IsValueTypeKind or IsReferenceTypeKind
            It could also be null for constraints like NotNull
            </summary>
            <example>
            <code>
            where T : MyClass
            </code>
            Would be parsed as:
            <code>
            {
                "Name": "MyClass"
            }
            </code>
            </example>
        </member>
        <member name="P:GenericConstraintInfo.ConstraintFlags">
            <summary>
            List of all applicable constraint flags for this type.
            Apply all applicable flags for the current item.
            </summary>
            <example>
            <code>
            where T : class
            </code>
            Would be parsed as:
            <code>
            {
              "ConstraintFlags": ["IsReferenceTypeKind"]
            }
            </code>
            </example>
        </member>
        <member name="T:DeclarationConstruct">
            <inheritdoc />
        </member>
        <member name="P:DeclarationConstruct.DeclarationType">
            <summary>
            The type of the declaration.
            </summary>
            <example>
            <code>
            public string MyProperty { get; set; }
            </code>
            Would be parsed as:
            <code>
            {
                "DeclarationType": "Property"
            }
            </code>
            </example>
        </member>
        <member name="P:DeclarationConstruct.DeclarationModifiers">
            <summary>
            The list of declaration modifiers.
            </summary>
            <example>
            <code>
            public static string MyField;
            </code>
            Would be parsed as:
            <code>
            {
                "DeclarationModifiers": ["Static"]
            }
            </code>
            </example>
        </member>
        <member name="P:DeclarationConstruct.AccessModifiers">
            <summary>
            The list of access modifiers.
            </summary>
            <example>
            <code>
            public string MyField;
            </code>
            Would be parsed as:
            <code>
            {
                "AccessModifiers": ["Public"]
            }
            </code>
            </example>
        </member>
        <member name="P:DeclarationConstruct.Attributes">
            <summary>
            The list of attributes applied to the declaration.
            </summary>
            <example>
            <code>
            [Obsolete]
            public string MyField;
            </code>
            Would be parsed as:
            <code>
            {
                "Attributes": [ { "Name": "Obsolete", "Arguments": [] } ]
            }
            </code>
            </example>
        </member>
        <member name="T:DelegateDeclaration">
            <inheritdoc />
        </member>
        <member name="P:DelegateDeclaration.CallableInfo">
            <summary>
            Information about the callable delegate.
            </summary>
        </member>
        <member name="T:EventDeclaration">
            <inheritdoc />
        </member>
        <member name="P:EventDeclaration.Type">
            <summary>
            The type of the event.
            </summary>
        </member>
        <member name="P:EventDeclaration.AccessModifierFlags">
            <summary>
            The access modifiers for the event.
            </summary>
            <example>
            <code>
            public event EventHandler MyEvent;
            </code>
            Would be parsed as:
            <code>
            {
                "AccessModifierFlags": ["Public"]
            }
            </code>
            </example>
        </member>
        <member name="T:FieldDeclaration">
            <inheritdoc />
        </member>
        <member name="P:FieldDeclaration.Type">
            <summary>
            The type of the field.
            </summary>
        </member>
        <member name="P:FieldDeclaration.AccessModifierFlags">
            <summary>
            The access modifiers for the field.
            </summary>
            <example>
            <code>
            public string MyField;
            </code>
            Would be parsed as:
            <code>
            {
                "AccessModifierFlags": ["Public"]
            }
            </code>
            </example>
        </member>
        <member name="P:FieldDeclaration.VariableModifierFlags">
            <summary>
            The variable modifiers for the field.
            </summary>
            <example>
            <code>
            static readonly string MyField;
            </code>
            Would be parsed as:
            <code>
            {
                "VariableModifierFlags": ["Static", "ReadOnly"]
            }
            </code>
            </example>
        </member>
        <member name="P:FieldDeclaration.DefaultValue">
            <summary>
            The default value of the field, if any.
            </summary>
        </member>
        <member name="T:PropertyDeclaration">
            <inheritdoc />
        </member>
        <member name="P:PropertyDeclaration.Type">
            <summary>
            Type of the property.
            </summary>
        </member>
        <member name="P:PropertyDeclaration.ModifierFlags">
            <summary>
            List of all applicable modifier flags for this property.
            Apply all applicable flags for the current item.
            </summary>
            <example>
            <code>
            public static string MyProperty { get; set; }
            </code>
            Would be parsed as:
            <code>
            {
                "ModifierFlags": ["Static"]
            }
            </code>
            </example>
        </member>
        <member name="P:PropertyDeclaration.DefaultValue">
            <summary>
            Default value of the member by expression, if applicable.
            </summary>
        </member>
        <member name="P:PropertyDeclaration.Getter">
            <summary>
            Definition of the custom getter for the property if applicable.
            </summary>
        </member>
        <member name="P:PropertyDeclaration.Setter">
            <summary>
            Definition of the custom setter for the property if applicable.
            </summary>
        </member>
        <member name="T:BranchingDirective">
            <summary>
            Represents a preprocessor branching directive (#if, #elif, #else, #endif).
            </summary>
        </member>
        <member name="P:BranchingDirective.Condition">
            <summary>
            The condition expression for the branch.
            </summary>
            <example>
            <code>
            {
               "Condition": "SOME_CONDITION"
            }
            </code>
            </example>
        </member>
        <member name="P:BranchingDirective.Default">
            <summary>
            The default condition if nothing else matches for the branch
            </summary>
        </member>
        <member name="P:BranchingDirective.Branches">
            <summary>
            Ordered list of branches because order matters.
            </summary>
        </member>
        <member name="P:DirectiveBranchComponent.Condition">
            <summary>
            The condition expression for the branch.
            </summary>
            <example>
            <code>
            {
              "Condition": "SOME_OTHER_CONDITION"
            }
            </code>
            </example>
        </member>
        <member name="P:DirectiveBranchComponent.Contents">
            <summary>
            Contents of the branch.
            </summary>
        </member>
        <member name="T:DirectiveConstruct">
            <inheritdoc />
        </member>
        <member name="P:DirectiveConstruct.DirectiveType">
            <summary>
            The type of the preprocessor directive.
            </summary>
            <example>
            <code>
            #region MyRegion
            </code>
            Would be parsed as:
            <code>
            {
                "DirectiveType": "Region"
            }
            </code>
            </example>
        </member>
        <member name="T:CustomDirective">
            <summary>
            Represents a custom preprocessor directive.
            </summary>
            <inheritdoc />
        </member>
        <member name="P:CustomDirective.Content">
            <summary>
            The raw content of the custom directive.
            </summary>
            <example>
            <code>
            #pragma ignore-warning myCustomDirective someValue
            </code>
            Would be parsed as:
            <code>
            {
              "Content": "#pragma ignore-warning myCustomDirective someValue",
            }
            </code>
            </example>
        </member>
        <member name="P:CustomDirective.Description">
            <summary>
            Description of what the custom directive does.
            </summary>
            <example>
            <code>
            #pragma ignore-warning myCustomDirective someValue
            </code>
            Would be parsed as:
            <code>
            {
              "Description": "This directive is used to ignore a specific warning.",
            }
            </code>
            </example>
        </member>
        <member name="T:EnDefinitionType">
            <summary>
            Represents symbol definition directives (#define, #undef)
            </summary>
        </member>
        <member name="F:EnDefinitionType.Define">
            <summary>
            Represents a #define directive.
            </summary>
        </member>
        <member name="F:EnDefinitionType.Undefine">
            <summary>
            Represents an #undef directive.
            </summary>
        </member>
        <member name="T:DefinitionDirective">
            <summary>
            Represents a preprocessor definition directive (#define, #undef).
            </summary>
        </member>
        <member name="P:DefinitionDirective.Symbol">
            <summary>
            The symbol being defined or undefined.
            </summary>
            <example>
            <code>
            #define MY_SYMBOL
            </code>
            Would be parsed as:
            <code>
            {
                "Symbol": "MY_SYMBOL"
            }
            </code>
            </example>
        </member>
        <member name="P:DefinitionDirective.DefinitionType">
            <summary>
            The type of definition directive.
            </summary>
            <example>
            <code>
            #define MY_SYMBOL
            </code>
            Would be parsed as:
            <code>
            {
                "DefinitionType": "Define"
            }
            </code>
            </example>
        </member>
        <member name="P:DefinitionDirective.Value">
            <summary>
            The value assigned to the symbol if applicable (for #define with value).
            </summary>
            <example>
            <code>
            #define MY_SYMBOL 10
            </code>
            Would be parsed as:
            <code>
            {
                "Value": "10"
            }
            </code>
            </example>
        </member>
        <member name="P:DefinitionDirective.DefinitionPurpose">
            <summary>
            The purpose of this symbol definition.
            </summary>
            <example>
            <code>
            #define MY_SYMBOL // This symbol is used for debugging.
            </code>
            Would be parsed as:
            <code>
            {
              "DefinitionPurpose": "This symbol is used for debugging."
            }
            </code>
            </example>
        </member>
        <member name="F:EnDiagnosticLevel.Warning">
            <summary>
            Represents a warning diagnostic.
            </summary>
        </member>
        <member name="F:EnDiagnosticLevel.Error">
            <summary>
            Represents an error diagnostic.
            </summary>
        </member>
        <member name="F:EnDiagnosticLevel.Other">
            <summary>
            Represents other types of diagnostics.
            </summary>
        </member>
        <member name="T:DiagnosticDirective">
            <summary>
            Represents a diagnostic preprocessor directive covering both warning and error directives.
            </summary>
            <inheritdoc />
        </member>
        <member name="P:DiagnosticDirective.Message">
            <summary>
            The message associated with the diagnostic.
            </summary>
            <example>
            <code>
            #warning This is a warning message.
            </code>
            Would be parsed as:
            <code>
            {
              "Message": "This is a warning message."
            }
            </code>
            </example>
        </member>
        <member name="P:DiagnosticDirective.Code">
            <summary>
            The code associated with the diagnostic, if any.
            </summary>
            <example>
            <code>
            #error CS1001
            </code>
            Would be parsed as:
            <code>
            {
              "Code": "CS1001"
            }
            </code>
            </example>
        </member>
        <member name="P:DiagnosticDirective.DiagnosticLevel">
            <summary>
            The severity level of the diagnostic.
            </summary>
            <example>
            <code>
            #warning This is a warning message.
            </code>
            Would be parsed as:
            <code>
            {
              "DiagnosticLevel": "Warning"
            }
            </code>
            </example>
        </member>
        <member name="T:IncludeDirective">
            <summary>
            Represents an include preprocessor directive.
            </summary>
            <inheritdoc />
        </member>
        <member name="P:IncludeDirective.FilePath">
            <summary>
            The path of the file to include.
            </summary>
            <example>
            <code>
            #include "myfile.h"
            </code>
            Would be parsed as:
            <code>
            {
              "FilePath": "myfile.h"
            }
            </code>
            </example>
        </member>
        <member name="P:IncludeDirective.InclusionPurpose">
            <summary>
            The purpose of including this file.
            </summary>
            <example>
            <code>
            #include "myfile.h" // Included for utility functions
            </code>
            Would be parsed as:
            <code>
            {
               "InclusionPurpose": "Included for utility functions"
            }
            </code>
            </example>
        </member>
        <member name="T:EnLineDirectiveModifierFlag">
            <summary>
            Represents flags for line preprocessor directive modifiers (hidden, default).
            </summary>
        </member>
        <member name="F:EnLineDirectiveModifierFlag.SetNumber">
            <summary>
            Represents setting a specific line number.
            </summary>
        </member>
        <member name="F:EnLineDirectiveModifierFlag.Hidden">
            <summary>
            Represents the #line hidden directive.
            </summary>
        </member>
        <member name="F:EnLineDirectiveModifierFlag.Default">
            <summary>
            Represents the #line default directive.
            </summary>
        </member>
        <member name="T:LineDirective">
            <summary>
            Represents a line preprocessor directive (covers hidden, default and value).
            </summary>
        </member>
        <member name="P:LineDirective.DirectiveLineNumber">
            <summary>
            The line number specified in the directive, if applicable.
            </summary>
            <example>
            <code>
            #line 200
            </code>
            Would be parsed as:
            <code>
            {
              "DirectiveLineNumber": 200
            }
            </code>
            </example>
        </member>
        <member name="P:LineDirective.FilePath">
            <summary>
            The file path specified in the directive, if applicable.
            </summary>
            <example>
            <code>
            #line 200 "custom.cs"
            </code>
            Would be parsed as:
            <code>
            {
              "FilePath": ["custom.cs"]
            }
            </code>
            </example>
        </member>
        <member name="P:LineDirective.ModifierFlags">
            <summary>
            The modifier flags for the directive (hidden, default).
            </summary>
            <example>
            <code>
            #line hidden
            </code>
            Would be parsed as:
            <code>
            {
               "ModifierFlags" : ["Hidden"]
            }
            </code>
            </example>
        </member>
        <member name="T:PragmaDirective">
            <summary>
            Represents a pragma preprocessor directive for compiler-specific instructions.
            </summary>
            <inheritdoc />
        </member>
        <member name="P:PragmaDirective.Command">
            <summary>
            The specific pragma command (e.g., "warning", "once", etc.).
            </summary>
            <example>
            <code>
            #pragma warning disable
            </code>
            Would be parsed as:
            <code>
            {
              "Command": "warning"
            }
            </code>
            </example>
        </member>
        <member name="P:PragmaDirective.Arguments">
            <summary>
            The arguments provided to the pragma command.
            </summary>
            <example>
            <code>
            #pragma warning disable CS0168
            </code>
            Would be parsed as:
            <code>
            {
               "Arguments": ["disable", "CS0168"]
            }
            </code>
            </example>
        </member>
        <member name="P:PragmaDirective.Description">
            <summary>
            Description of what the pragma does.
            </summary>
            <example>
            <code>
            #pragma warning disable CS0168 // Variable is declared but never used
            </code>
            Would be parsed as:
            <code>
            {
               "Description": "Disable warning for unused variable"
            }
            </code>
            </example>
        </member>
        <member name="T:RegionDirective">
            <summary>
            Represents a region preprocessor directive (also covers endregion).
            </summary>
            <inheritdoc />
        </member>
        <member name="P:RegionDirective.Name">
            <summary>
            The name/description of the region.
            </summary>
            <example>
            <code>
            #region MyRegion
            </code>
            Would be parsed as:
            <code>
            {
              "Name": "MyRegion"
            }
            </code>
            </example>
        </member>
        <member name="P:RegionDirective.Constructs">
            <summary>
            The constructs contained within this region.
            </summary>
        </member>
        <member name="P:RegionDirective.RegionPurpose">
            <summary>
            Describes the purpose of this region in the code.
            </summary>
            <example>
            <code>
            #region MyRegion // This region contains utility functions.
            </code>
            Would be parsed as:
            <code>
            {
               "RegionPurpose": "This region contains utility functions."
            }
            </code>
            </example>
        </member>
        <member name="T:EnBracketType">
            <summary>
            Defines the possible types of brackets.
            </summary>
        </member>
        <member name="F:EnBracketType.Square">
            <summary>
            Represents square brackets [].
            </summary>
        </member>
        <member name="F:EnBracketType.Round">
            <summary>
            Represents round brackets ().
            </summary>
        </member>
        <member name="F:EnBracketType.Angle">
            <summary>
            Represents angle brackets &lt;&gt;.
            </summary>
        </member>
        <member name="F:EnBracketType.Curly">
            <summary>
            Represents curly brackets {}.
            </summary>
        </member>
        <member name="T:BracketExpression">
            <inheritdoc />
        </member>
        <member name="P:BracketExpression.BracketType">
            <summary>
            Type of the brackets.
            </summary>
            <example>
            <code>
            [1, 2, 3]
            </code>
            Would be parsed as:
            <code>
            {
                "BracketType": "Square"
            }
            </code>
            </example>
        </member>
        <member name="P:BracketExpression.Expression">
            <summary>
            Expression within the brackets.
            </summary>
        </member>
        <member name="T:EnCallableUseModifierFlag">
            <summary>
            Defines the possible modifier flags for a callable use.
            </summary>
        </member>
        <member name="F:EnCallableUseModifierFlag.IsBuiltIn">
            <summary>
            Indicates that the callable is a built-in function.
            </summary>
        </member>
        <member name="T:CallableUseExpression">
            <summary>
            Represents a callable use.
            </summary>
            <remarks>
            Must call expression builder for all [named] arguments
            </remarks>
        </member>
        <member name="P:CallableUseExpression.FunctionName">
            <summary>
            Name of the function being called.
            Null if the object itself is being called.
            </summary>
            <example>
            <code>
            myArray.Sort();
            </code>
            Would be parsed as:
            <code>
            {
                "FunctionName": "Sort"
            }
            </code>
            </example>
        </member>
        <member name="P:CallableUseExpression.Arguments">
            <summary>
            List of arguments for the function, passed as expressions.
            </summary>
        </member>
        <member name="P:CallableUseExpression.NamedArguments">
            <summary>
            Dictionary of named arguments for the function, passed as expressions.
            </summary>
        </member>
        <member name="P:CallableUseExpression.GenericParameters">
            <summary>
            Generic parameters for the function.
            </summary>
            <example>
            <code>
            MyMethod&lt;string&gt;();
            </code>
            Would be parsed as:
            <code>
            {
                "GenericParameters": [ { "Name": "string" } ]
            }
            </code>
            </example>
        </member>
        <member name="P:CallableUseExpression.ReturnType">
            <summary>
            Return type of the callable, might be necessary for overloaded callables.
            </summary>
            <example>
            <code>
            string result = MyMethod();
            </code>
            Would be parsed as:
            <code>
            {
              "ReturnType": { "Name": "string" }
            }
            </code>
            </example>
        </member>
        <member name="P:CallableUseExpression.Expression">
            <summary>
            Expression used to call the function if applicable.
            e.g. a.b.c() or a[0].b.c()
            Actual function not included in the variable path
            </summary>
        </member>
        <member name="P:CallableUseExpression.CallableUseModifierFlags">
            <summary>
            List of all applicable modifier flags for this callable.
            Apply all applicable flags for the current item.
            </summary>
            <example>
            <code>
            // Assuming a built-in function
            myArray.Sort();
            </code>
            Would be parsed as:
            <code>
            {
                "CallableUseModifierFlags": ["IsBuiltIn"]
            }
            </code>
            </example>
        </member>
        <member name="T:ExpressionConstruct">
            <inheritdoc />
        </member>
        <member name="T:ComprehensionExpression">
            <inheritdoc />
        </member>
        <member name="P:ComprehensionExpression.Filter">
            <summary>
            The expression that filters the collection.
            </summary>
        </member>
        <member name="P:ComprehensionExpression.Result">
            <summary>
            The expression that is evaluated for each item in the collection.
            </summary>
        </member>
        <member name="P:ComprehensionExpression.Collection">
            <summary>
            The expression that represents the collection to be iterated over.
            </summary>
        </member>
        <member name="P:ComprehensionExpression.ResultTypeInfo">
            <summary>
            The type information for the result of the comprehension.
            </summary>
        </member>
        <member name="T:EnFormatStringComponentType">
            <summary>
            Defines the possible types of format string components.
            </summary>
        </member>
        <member name="F:EnFormatStringComponentType.Text">
            <summary>
            Represents a text component.
            </summary>
        </member>
        <member name="F:EnFormatStringComponentType.Expression">
            <summary>
            Represents an expression component.
            </summary>
        </member>
        <member name="T:FormatStringExpression">
            <inheritdoc />
        </member>
        <member name="P:FormatStringExpression.Components">
            <summary>
            The components of the format string.
            </summary>
            <example>
            <code>
            $"Hello, {name}!"
            </code>
            Would be parsed as:
            <code>
            {
                "Components": [
                    { "ComponentType": "Text", "Text": "Hello, " },
                    { "ComponentType": "Expression", /* ... Expression details ... */ },
                    { "ComponentType": "Text", "Text": "!" }
                ]
            }
            </code>
            </example>
        </member>
        <member name="T:FormatStringComponent">
            <summary>
            Represents a component of a format string.
            </summary>
        </member>
        <member name="P:FormatStringComponent.ComponentType">
            <summary>
            The type of the format string component.
            </summary>
            <example>
            <code>
            "Hello, "
            </code>
            Would have a component parsed as:
            <code>
            {
               "ComponentType": "Text"
            }
            </code>
            On the other hand, an expression like:
            <code>
            {value:F2}
            </code>
            Would have a component parsed as:
            <code>
            {
               "ComponentType": "Expression"
            }
            </code>
            </example>
        </member>
        <member name="T:FormatStringTextComponent">
            <inheritdoc />
        </member>
        <member name="P:FormatStringTextComponent.Text">
            <summary>
            The text content of the component.
            </summary>
            <example>
            <code>
            $"Hello, {name}!"
            </code>
            Would have a text component parsed as:
            <code>
            {
                "Text": "Hello, "
            }
            </code>
            </example>
        </member>
        <member name="T:FormatStringExpressionComponent">
            <inheritdoc />
        </member>
        <member name="P:FormatStringExpressionComponent.Expression">
            <summary>
            The expression contained within the format string.
            </summary>
        </member>
        <member name="P:FormatStringExpressionComponent.Pipes">
            <summary>
            The pipes applied to the expression in the format string.
            </summary>
            <example>
            <code>
            $"{value:F2}"
            </code>
            Would be parsed as:
            <code>
            {
               "Pipes": [{ "Purpose": "Format as fixed-point with 2 decimal places" }]
            }
            </code>
            </example>
        </member>
        <member name="T:FormatStringExpressionPipe">
            <summary>
            Represents a pipe applied to an expression within a format string.
            </summary>
        </member>
        <member name="P:FormatStringExpressionPipe.Purpose">
            <summary>
            Specifies what the pipe is meant to do.
            e.g. Show the value to three decimal places
            e.g. Show the value in HH:mm:ss format
            </summary>
            <example>
            <code>
            {value:F2}
            </code>
            Would be parsed as:
            <code>
            {
               "Purpose": "Format as fixed-point with 2 decimal places"
            }
            </code>
            </example>
        </member>
        <member name="T:LambdaExpression">
            <inheritdoc />
        </member>
        <member name="P:LambdaExpression.CallableInfo">
            <summary>
            Information about the callable (lambda function).
            </summary>
        </member>
        <member name="P:LambdaExpression.Constructs">
            <summary>
            Lambda function body that contains the constructs to be executed.
            </summary>
        </member>
        <member name="T:LiteralValueExpression">
            <summary>
            Represents a literal value expression
            Only meant to be used for primitives
            Objects to be instanciated through callable use
            </summary>
        </member>
        <member name="P:LiteralValueExpression.LiteralValue">
            <summary>
            The literal value as a string.
            </summary>
            <example>
            <code>
            123
            </code>
            Would be parsed as:
            <code>
            {
              "LiteralValue": "123"
            }
            </code>
            </example>
        </member>
        <member name="P:LiteralValueExpression.Type">
            <summary>
            The type information for the literal value.
            </summary>
        </member>
        <member name="T:NewVariableExpression">
            <inheritdoc />
        </member>
        <member name="P:NewVariableExpression.VariableName">
            <summary>
            The name of the new variable being declared.
            </summary>
            <example>
            <code>
            int myVariable = 10;
            </code>
            Would be parsed as:
            <code>
            {
                "VariableName": "myVariable"
            }
            </code>
            </example>
        </member>
        <member name="P:NewVariableExpression.Type">
            <summary>
            Type of newly made variable.
            </summary>
        </member>
        <member name="P:NewVariableExpression.DefaultValue">
            <summary>
            Value of the variable by expression, if applicable i.e. if defined
            </summary>
        </member>
        <member name="P:NewVariableExpression.ModifierFlags">
            <summary>
            List of all applicable modifier flags for this variable.
            Apply all applicable flags for the current item.
            </summary>
            <example>
            <code>
            const int myVariable = 10;
            </code>
            Would be parsed as:
            <code>
            {
               "ModifierFlags": ["Constant"]
            }
            </code>
            </example>
        </member>
        <member name="T:EnBinaryOperator">
            <summary>
            Assignment operators to be covered by translating to full assignment statements.
            </summary>
            <summary>
            Assignment operators to be covered by translating to full assignment statements.
            </summary>
        </member>
        <member name="F:EnBinaryOperator.Add">
            <summary>
            Represents the addition operator (+).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.Subtract">
            <summary>
            Represents the subtraction operator (-).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.Multiply">
            <summary>
            Represents the multiplication operator (*).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.Divide">
            <summary>
            Represents the division operator (/).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.Modulo">
            <summary>
            Represents the modulo operator (%).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.Power">
            <summary>
            Represents the power operator (**).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.Equal">
            <summary>
            Represents the equality operator (==).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.NotEqual">
            <summary>
            Represents the inequality operator (!=).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.GreaterThan">
            <summary>
            Represents the greater than operator (>).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.LessThan">
            <summary>
            Represents the less than operator (&lt;).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.GreaterThanOrEqual">
            <summary>
            Represents the greater than or equal to operator (>=).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.LessThanOrEqual">
            <summary>
            Represents the less than or equal to operator (&lt;=).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.LogicalAnd">
            <summary>
            Represents the logical AND operator (&amp;&amp;).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.LogicalOr">
            <summary>
            Represents the logical OR operator (||).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.BitwiseAnd">
            <summary>
            Represents the bitwise AND operator (&amp;).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.BitwiseOr">
            <summary>
            Represents the bitwise OR operator (|).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.BitwiseXor">
            <summary>
            Represents the bitwise XOR operator (^).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.BitwiseLeftShift">
            <summary>
            Represents the bitwise left shift operator (&lt;&lt;).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.BitwiseRightShift">
            <summary>
            Represents the bitwise right shift operator (>>).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.NullCoalescing">
            <summary>
            Represents the null coalescing operator (??).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.ReferenceEqual">
            <summary>
            Represents reference equality (===).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.ReferenceNotEqual">
            <summary>
            Represents reference inequality (!==).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.PointerToMember">
            <summary>
            Represents pointer to member operator (->).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.RangeBetween">
            <summary>
            Represents the range between operator (..).
            </summary>
        </member>
        <member name="F:EnBinaryOperator.SliceStartEnd">
            <summary>
            Represents the slice with start and end (a:b).
            </summary>
        </member>
        <member name="T:BinaryOperatorExpression">
            <inheritdoc />
        </member>
        <member name="P:BinaryOperatorExpression.Operator">
            <summary>
            The binary operator.
            </summary>
            <example>
            <code>
            a + b
            </code>
            Would be parsed as:
            <code>
            {
                "Operator": "Add"
            }
            </code>
            </example>
        </member>
        <member name="P:BinaryOperatorExpression.Left">
            <summary>
            The left operand of the binary operator.
            </summary>
        </member>
        <member name="P:BinaryOperatorExpression.Right">
            <summary>
            The right operand of the binary operator.
            </summary>
        </member>
        <member name="T:EnOperatorAssociativity">
            <summary>
            Defines the possible associativities of operators.
            </summary>
        </member>
        <member name="F:EnOperatorAssociativity.LeftToRight">
            <summary>
            Left-to-right associativity.
            </summary>
        </member>
        <member name="F:EnOperatorAssociativity.RightToLeft">
            <summary>
            Right-to-left associativity.
            </summary>
        </member>
        <member name="T:OperatorExpression">
            <inheritdoc />
        </member>
        <member name="P:OperatorExpression.OperatorType">
            <summary>
            The type of the operator.
            </summary>
            <example>
            <code>
            a + b
            </code>
            Would be parsed as:
            <code>
            {
                "OperatorType": "Binary"
            }
            </code>
            </example>
        </member>
        <member name="P:OperatorExpression.Associativity">
            <summary>
            The associativity of the operator.
            </summary>
            <example>
            <code>
            a + b + c
            </code>
            Would be parsed as:
            <code>
            {
                "Associativity": "LeftToRight"
            }
            </code>
            </example>
        </member>
        <member name="T:EnTernaryOperator">
            <summary>
            Defines the possible ternary operators.
            </summary>
        </member>
        <member name="F:EnTernaryOperator.ConditionalTernary">
            <summary>
            Represents the conditional ternary operator (?:).
            </summary>
        </member>
        <member name="F:EnTernaryOperator.RangeBetweenWithStep">
            <summary>
            Represents a range with a step operator.
            </summary>
        </member>
        <member name="F:EnTernaryOperator.SliceStartEndWithStep">
            <summary>
            Represents a slice with start, end, and step operator.
            </summary>
        </member>
        <member name="T:TernaryOperatorExpression">
            <inheritdoc />
        </member>
        <member name="P:TernaryOperatorExpression.Operator">
            <summary>
            The ternary operator.
            </summary>
            <example>
            <code>
            condition ? consequent : alternative
            </code>
            Would be parsed as:
            <code>
            {
                "Operator": "ConditionalTernary"
            }
            </code>
            </example>
        </member>
        <member name="P:TernaryOperatorExpression.Condition">
            <summary>
            The condition or step of the ternary operator.
            </summary>
        </member>
        <member name="P:TernaryOperatorExpression.Left">
            <summary>
            The left operand of the ternary operator.
            </summary>
        </member>
        <member name="P:TernaryOperatorExpression.Right">
            <summary>
            The right operand of the ternary operator.
            </summary>
        </member>
        <member name="T:EnUnaryOperator">
            <summary>
            Defines the possible unary operators.
            </summary>
        </member>
        <member name="F:EnUnaryOperator.LogicalNot">
            <summary>
            Represents the logical NOT operator (!).
            </summary>
        </member>
        <member name="F:EnUnaryOperator.BitwiseNot">
            <summary>
            Represents the bitwise NOT operator (~).
            </summary>
        </member>
        <member name="F:EnUnaryOperator.Increment">
            <summary>
            Represents the increment operator (++).
            </summary>
        </member>
        <member name="F:EnUnaryOperator.Decrement">
            <summary>
            Represents the decrement operator (--).
            </summary>
        </member>
        <member name="F:EnUnaryOperator.UnaryPlus">
            <summary>
            Represents the unary plus operator (+).
            </summary>
        </member>
        <member name="F:EnUnaryOperator.UnaryMinus">
            <summary>
            Represents the unary minus operator (-).
            </summary>
        </member>
        <member name="F:EnUnaryOperator.AddressOf">
            <summary>
            Address-of operator (&amp;) in C++.
            </summary>
        </member>
        <member name="F:EnUnaryOperator.Dereference">
            <summary>
            Dereference operator (*) in C++.
            </summary>
        </member>
        <member name="F:EnUnaryOperator.Unpacking">
            <summary>
            Python-style unpacking operator (*).
            </summary>
        </member>
        <member name="T:UnaryOperatorExpression">
            <inheritdoc />
        </member>
        <member name="P:UnaryOperatorExpression.Operator">
            <summary>
            The unary operator.
            </summary>
            <example>
            <code>
            !true
            </code>
            Would be parsed as:
            <code>
            {
                "Operator": "LogicalNot"
            }
            </code>
            </example>
        </member>
        <member name="P:UnaryOperatorExpression.Operand">
            <summary>
            The operand of the unary operator.
            </summary>
        </member>
        <member name="T:VariableUseExpression">
            <inheritdoc />
        </member>
        <member name="P:VariableUseExpression.VariableName">
            <summary>
            Name of the variable.
            </summary>
            <example>
            <code>
            myVariable
            </code>
            Would be parsed as:
            <code>
            {
                "VariableName": "myVariable"
            }
            </code>
            </example>
        </member>
        <member name="P:VariableUseExpression.Path">
            <summary>
            List of components of the variable path (e.g. a.b.c or a[0].b.c).
            If the variable is not a path-supported type, then this will be null.
            Does not include the initial variable name.
            </summary>
            <example>
            <code>
            myObject.myField
            </code>
            Would be parsed as:
            <code>
            {
              "VariableName": "myObject",
              "Path": [ { "Value": "myField" } ]
            }
            </code>
            </example>
        </member>
        <member name="T:VariablePathComponent">
            <summary>
            Represents a component of a variable path.
            </summary>
        </member>
        <member name="P:VariablePathComponent.Value">
            <summary>
            The value of this path component.
            </summary>
            <example>
            <code>
            myObject.myField
            </code>
            Would have a component parsed as:
            <code>
            {
               "Value": "myField"
            }
            </code>
            </example>
        </member>
        <member name="P:VariablePathComponent.Type">
            <summary>
            The type information for this component.
            </summary>
        </member>
        <member name="T:BranchingStatement">
            <inheritdoc />
        </member>
        <member name="P:BranchingStatement.Condition">
            <summary>
            The condition of the branching statement, which is evaluated to determine which branch to execute.
            </summary>
        </member>
        <member name="P:BranchingStatement.Branches">
            <summary>
            Ordered list of branches because order matters.
            </summary>
        </member>
        <member name="P:BranchingStatement.Default">
            <summary>
            The default branch that is executed if no other conditions are met.
            </summary>
        </member>
        <member name="T:BranchComponent">
            <summary>
            Represents a component of a branching statement, such as an if, else if, or else block.
            </summary>
        </member>
        <member name="P:BranchComponent.Condition">
            <summary>
            The condition that determines whether this branch should be executed.
            </summary>
        </member>
        <member name="P:BranchComponent.Constructs">
            <summary>
            The list of constructs (statements, expressions, etc.) that are executed if this branch is taken.
            </summary>
        </member>
        <member name="T:CallableStatement">
            <inheritdoc />
        </member>
        <member name="P:CallableStatement.Callable">
            <summary>
            The callable block
            </summary>
        </member>
        <member name="T:StatementConstruct">
            <inheritdoc />
        </member>
        <member name="P:StatementConstruct.StatementType">
            <summary>
            The type of the statement.
            </summary>
            <example>
            <code>
            return 0;
            </code>
            Would be parsed as:
            <code>
            {
                "StatementType": "ControlFlow"
            }
            </code>
            </example>
        </member>
        <member name="P:StatementConstruct.Attributes">
            <summary>
            The list of attributes applied to the statement.
            </summary>
            <example>
            <code>
            [Obsolete]
            return;
            </code>
            Would be parsed as:
            <code>
            {
                "Attributes": [ { "Name": "Obsolete", "Arguments": [] } ]
            }
            </code>
            </example>
        </member>
        <member name="T:EnControlFlowStatementType">
            <summary>
            Defines the possible types of control flow statements.
            </summary>
        </member>
        <member name="F:EnControlFlowStatementType.Break">
            <summary>
            Represents a break statement.
            </summary>
        </member>
        <member name="F:EnControlFlowStatementType.Continue">
            <summary>
            Represents a continue statement.
            </summary>
        </member>
        <member name="F:EnControlFlowStatementType.Goto">
            <summary>
            Represents a goto statement.
            </summary>
        </member>
        <member name="F:EnControlFlowStatementType.Return">
            <summary>
            Represents a return statement.
            </summary>
        </member>
        <member name="F:EnControlFlowStatementType.Yield">
            <summary>
            Represents a yield statement.
            </summary>
        </member>
        <member name="F:EnControlFlowStatementType.Throw">
            <summary>
            Represents a throw statement.
            </summary>
        </member>
        <member name="T:ControlFlowStatement">
            <inheritdoc />
        </member>
        <member name="P:ControlFlowStatement.ControlType">
            <summary>
            Type of the control flow.
            </summary>
            <example>
            <code>
            return;
            </code>
            Would be parsed as:
            <code>
            {
                "ControlType": "Return"
            }
            </code>
            </example>
        </member>
        <member name="P:ControlFlowStatement.Expression">
            <summary>
            Expression for the control flow, if applicable.
            Return value, yield value, throw value etc.
            Continue and/or break would likely not have an expression.
            </summary>
        </member>
        <member name="T:CustomStatement">
            <inheritdoc />
        </member>
        <member name="P:CustomStatement.LogicDescription">
            <summary>
            Description of the logic for/within the statement
            </summary>
        </member>
        <member name="P:CustomStatement.LogicPurpose">
            <summary>
            Description of what the logic in a for/within is meant to do
            </summary>
        </member>
        <member name="T:ExceptionHandlingStatement">
            <inheritdoc />
        </member>
        <member name="P:ExceptionHandlingStatement.Try">
            <summary>
            The list of constructs to execute in the try block.
            e.g., statements, expressions, etc.
            </summary>
        </member>
        <member name="P:ExceptionHandlingStatement.Catches">
            <summary>
            The list of catch blocks to handle exceptions.
            </summary>
        </member>
        <member name="P:ExceptionHandlingStatement.Finally">
            <summary>
            The list of constructs to execute in the finally block.
            e.g., statements, expressions, etc.
            </summary>
        </member>
        <member name="T:CatchComponent">
            <summary>
            Represents a catch block in a try-catch-finally statement.
            </summary>
        </member>
        <member name="P:CatchComponent.Variable">
            <summary>
            The variable that will hold the exception object.
            </summary>
        </member>
        <member name="P:CatchComponent.Constructs">
            <summary>
            The list of constructs to execute if the exception is caught.
            e.g., statements, expressions, etc.
            </summary>
        </member>
        <member name="T:ExportStatement">
            <inheritdoc />
        </member>
        <member name="P:ExportStatement.ModulePath">
            <summary>
            Path to the module being imported.
            Absolute path if possible, file path provided as context.
            System modules only need the module path.
            </summary>
            <example>
            <code>
            export { myFunction } from './my-module';
            </code>
            Would be parsed as:
            <code>
            {
                "ModulePath": "./my-module"
            }
            </code>
            </example>
        </member>
        <member name="P:ExportStatement.ImportedSymbols">
            <summary>
            List of imports or using directives by expression, represented as structured information.
            </summary>
            <example>
            <code>
            export { myFunction } from './my-module';
            </code>
            Would be parsed as:
            <code>
            {
              "ImportedSymbols": [{
                    "Name": "myFunction",
                    "Alias": "myFunction"
                }]
            }
            </code>
            </example>
        </member>
        <member name="T:ExportedSymbolInfo">
            <summary>
            Represents information about a symbol being exported.
            </summary>
        </member>
        <member name="P:ExportedSymbolInfo.Name">
            <summary>
            The name of the symbol being exported.
            </summary>
            <example>
            <code>
            export { myFunction } from './my-module';
            </code>
            Would be parsed as:
            <code>
            {
                "Name": "myFunction"
            }
            </code>
            </example>
        </member>
        <member name="P:ExportedSymbolInfo.Alias">
            <summary>
            The alias of the symbol being exported, if any.
            </summary>
            <example>
            <code>
            export { myFunction as myFunc } from './my-module';
            </code>
            Would be parsed as:
            <code>
            {
              "Alias": "myFunc"
            }
            </code>
            </example>
        </member>
        <member name="T:EnImportModifierFlag">
            <summary>
            Defines the possible modifier flags for an import statement.
            </summary>
        </member>
        <member name="F:EnImportModifierFlag.System">
            <summary>
            Import is a system module.
            Part of the standard library.
            </summary>
        </member>
        <member name="F:EnImportModifierFlag.Relative">
            <summary>
            Import is a relative path.
            </summary>
        </member>
        <member name="F:EnImportModifierFlag.Wildcard">
            <summary>
            Import is a wildcard import.
            </summary>
        </member>
        <member name="T:ImportStatement">
            <inheritdoc />
        </member>
        <member name="P:ImportStatement.ModulePath">
            <summary>
            Path to the module being imported.
            Absolute path if possible, file path provided as context.
            System modules only need the module path.
            </summary>
            <example>
            <code>
            using System;
            </code>
            Would be parsed as:
            <code>
            {
              "ModulePath": "System"
            }
            </code>
            </example>
        </member>
        <member name="P:ImportStatement.FilePath">
            <summary>
            Path to the module being imported.
            Absolute path if possible, current file path provided as context.
            Only applicable if the module is not a system module and imports are based on paths.
            </summary>
            <example>
            <code>
            import myModule from './my-module';
            </code>
            Would be parsed as:
            <code>
            {
               "FilePath": "./my-module"
            }
            </code>
            </example>
        </member>
        <member name="P:ImportStatement.ImportedSymbols">
            <summary>
            List of imports or using directives by expression, represented as structured information.
            </summary>
            <example>
            <code>
            using System.Collections.Generic;
            </code>
            Would be parsed as:
            <code>
            {
              "ImportedSymbols": [{
                    "Name": "Generic",
                    "Alias": "Generic"
                }]
            }
            </code>
            </example>
        </member>
        <member name="P:ImportStatement.ImportModifierFlags">
            <summary>
            List of all applicable modifier flags for this import.
            Apply all applicable flags for the current item.
            </summary>
            <example>
            <code>
            using static System.Math;
            </code>
            Would be parsed as:
            <code>
            {
              "ImportModifierFlags": ["Static"] // Assuming a 'Static' flag exists or is analogous to a custom flag
            }
            </code>
            </example>
        </member>
        <member name="T:ImportedSymbolInfo">
            <summary>
            Represents information about a symbol being imported.
            </summary>
        </member>
        <member name="P:ImportedSymbolInfo.Name">
            <summary>
            The name of the symbol being imported.
            </summary>
            <example>
            <code>
            import { myFunction } from './my-module';
            </code>
            Would be parsed as:
            <code>
            {
                "Name": "myFunction"
            }
            </code>
            </example>
        </member>
        <member name="P:ImportedSymbolInfo.Alias">
            <summary>
            The alias of the symbol being imported, if any.
            </summary>
            <example>
            <code>
            import { myFunction as myFunc } from './my-module';
            </code>
            Would be parsed as:
            <code>
            {
              "Alias": "myFunc"
            }
            </code>
            </example>
        </member>
        <member name="T:LoopingStatement">
            <inheritdoc />
        </member>
        <member name="P:LoopingStatement.Initial">
            <summary>
            Expression that is evaluated before the loop starts. e.g. int i = 0;
            </summary>
        </member>
        <member name="P:LoopingStatement.Condition">
            <summary>
            Expression that is evaluated before each iteration of the loop. e.g. i &lt; 10;
            </summary>
        </member>
        <member name="P:LoopingStatement.Increment">
            <summary>
            Expression that is evaluated after each iteration of the loop. e.g. i++;
            </summary>
        </member>
        <member name="P:LoopingStatement.Constructs">
            <summary>
            Ordered list of statements that are executed in the loop.
            </summary>
        </member>
        <member name="P:LoopingStatement.IsAtLeastOnce">
            <summary>
            Whether the loop is at least once. e.g. for(;;) or while(true) or do-while()
            </summary>
            <example>
            <code>
            do { ... } while(true);
            </code>
            Would be parsed as:
            <code>
            {
               "IsAtLeastOnce": true
            }
            </code>
            </example>
        </member>
        <member name="T:EnMarkingStatementType">
            <summary>
            Defines the possible types of marking statements.
            </summary>
        </member>
        <member name="F:EnMarkingStatementType.Label">
            <summary>
            Represents a label.
            </summary>
        </member>
        <member name="T:MarkingStatement">
            <inheritdoc />
        </member>
        <member name="P:MarkingStatement.MarkingType">
            <summary>
            The type of marking statement.
            </summary>
            <example>
            <code>
            myLabel:
            </code>
            Would be parsed as:
            <code>
            {
                "MarkingType": "Label"
            }
            </code>
            </example>
        </member>
        <member name="P:MarkingStatement.Expression">
            <summary>
            Expression for the marking, if applicable.
            Labels would likely have an expression for the label name.
            Transactions would likely have an expression for the transaction name.
            </summary>
        </member>
        <member name="F:EnItemTerminationReason.Mistake">
            <summary>
            Indicates that the iterable has been terminated due to a parsing error.
            </summary>
        </member>
        <member name="F:EnItemTerminationReason.Finished">
            <summary>
            Indicates that the iterable has been terminated due to reaching the end of the iterable.
            </summary>
        </member>
        <member name="P:EndItem.TerminationReason">
            <summary>
            Indicates why the end of the item has been reached.
            </summary>
        </member>
        <member name="F:EnIterableBuilderTool.ScrollDown">
            <summary>
            Represents a scroll down action.
            </summary>
        </member>
        <member name="F:EnIterableBuilderTool.PageDown">
            <summary>
            Represents a page down action.
            </summary>
        </member>
        <member name="F:EnIterableBuilderTool.NewItem">
            <summary>
            Represents a new item.
            </summary>
        </member>
        <member name="F:EnIterableBuilderTool.EndItem">
            <summary>
            Represents the end of an iterable.
            </summary>
        </member>
        <member name="F:EnIterableInsertAt.End">
            <summary>
            Indicates that the item should be inserted at the end of the iterable.
            </summary>
        </member>
        <member name="F:EnIterableInsertAt.Start">
            <summary>
            Indicates that the item should be inserted at the beginning of the iterable.
            </summary>
        </member>
        <member name="P:NewItem.InsertAt">
            <summary>
            Indicates whether a new item has been created.
            </summary>
        </member>
        <member name="F:EnObjectBuilderTool.ScrollDown">
            <summary>
            Represents a scroll down action.
            </summary>
        </member>
        <member name="F:EnObjectBuilderTool.PageDown">
            <summary>
            Represents a page down action.
            </summary>
        </member>
        <member name="F:EnObjectBuilderTool.NewProperty">
            <summary>
            Represents a new property.
            </summary>
        </member>
        <member name="F:EnObjectBuilderTool.EndItem">
            <summary>
            Represents the end of an object.
            </summary>
        </member>
        <member name="P:NewProperty.PropertyName">
            <summary>
            Indicates the name of the property.
            </summary>
        </member>
        <member name="T:EnConstructType">
            <summary>
            Defines the possible tool selections.
            </summary>
        </member>
        <member name="F:EnConstructType.ScrollDown">
            <summary>
            Represents a scroll down action.
            </summary>
        </member>
        <member name="F:EnConstructType.PreprocessorDirective">
            <summary>
            Represents a preprocessor directive selection.
            </summary>
        </member>
        <member name="F:EnConstructType.Block">
            <summary>
            Represents the start of a named block of code
            </summary>
        </member>
        <member name="F:EnConstructType.Statement">
            <summary>
            Represents a statement selection.
            </summary>
        </member>
        <member name="F:EnConstructType.Declaration">
            <summary>
            Represents a declaration selection.
            </summary>
        </member>
        <member name="F:EnConstructType.Expression">
            <summary>
            Represents a Expression selection.
            </summary>
        </member>
        <member name="F:EnConstructType.EndConstruct">
            <summary>
            Represents the end of a construct.
            e.g. end of a class, method, or namespace.
            or expression or statement depending on the context.
            </summary>
        </member>
        <member name="F:EnConstructType.Finish">
            <summary>
            Represents the finish action.
            i.e. completion of the parsing process.
            This is the final selection in the parser.
            </summary>
        </member>
        <member name="T:ConstructSelector">
            <summary>
            Represents a selection in the parser.
            </summary>
        </member>
        <member name="P:ConstructSelector.ToolSelection">
            <summary>
            The selected tool.
            </summary>
        </member>
        <member name="T:PageDown">
            <summary>
            Represents a page down action in the parser, indicating how many lines to scroll.
            </summary>
        </member>
        <member name="P:PageDown.OverlappingLines">
            <summary>
            The number of overlapping lines for next page to current page.
            This is used to determine how many lines to scroll down.
            Must be a positive integer.
            </summary>
        </member>
        <member name="T:ScrollDown">
            <summary>
            Represents a scrolling action in the parser, indicating how many lines to scroll.
            </summary>
        </member>
        <member name="P:ScrollDown.NumberOfLines">
            <summary>
            The number of lines to scroll, must be a positive integer.
            </summary>
        </member>
        <member name="T:EnBlockType">
            <summary>
            Defines the possible types of code blocks.
            </summary>
        </member>
        <member name="F:EnBlockType.ScrollDown">
            <summary>
            Represents a scroll down action.
            </summary>
        </member>
        <member name="F:EnBlockType.Namespace">
            <summary>
            Represents a namespace block.
            </summary>
        </member>
        <member name="F:EnBlockType.Class">
            <summary>
            Represents a class block.
            </summary>
        </member>
        <member name="F:EnBlockType.Struct">
            <summary>
            Represents a struct block.
            </summary>
        </member>
        <member name="F:EnBlockType.Interface">
            <summary>
            Represents an interface block.
            </summary>
        </member>
        <member name="F:EnBlockType.Enum">
            <summary>
            Represents an enum block.
            </summary>
        </member>
        <member name="F:EnBlockType.Record">
            <summary>
            Represents a record block.
            </summary>
        </member>
        <member name="F:EnBlockType.Callable">
            <summary>
            Represents a callable block (e.g., method, function).
            </summary>
        </member>
        <member name="P:BlockSelector.ToolSelection">
            <summary>
            The type of the block.
            </summary>
            <example>
            <code>
            public class MyClass { }
            </code>
            Would be parsed as:
            <code>
            {
                "ToolSelection": "Class"
            }
            </code>
            </example>
        </member>
        <member name="T:EnDeclarationType">
            <summary>
            Defines the possible types of declarations.
            </summary>
        </member>
        <member name="F:EnDeclarationType.ScrollDown">
            <summary>
            Represents a scroll down action.
            </summary>
        </member>
        <member name="F:EnDeclarationType.Delegate">
            <summary>
            Represents a delegate declaration.
            </summary>
        </member>
        <member name="F:EnDeclarationType.Property">
            <summary>
            Represents a property declaration.
            </summary>
        </member>
        <member name="F:EnDeclarationType.Field">
            <summary>
            Represents a field declaration.
            </summary>
        </member>
        <member name="F:EnDeclarationType.Event">
            <summary>
            Represents an event declaration.
            </summary>
        </member>
        <member name="P:DeclarationSelector.ToolSelection">
            <summary>
            The type of the declaration.
            </summary>
            <example>
            <code>
            public string MyProperty { get; set; }
            </code>
            Would be parsed as:
            <code>
            {
                "ToolSelection": "Property"
            }
            </code>
            </example>
        </member>
        <member name="T:EnDirectiveType">
            <summary>
            Defines the possible types of preprocessor directives.
            </summary>
        </member>
        <member name="F:EnDirectiveType.ScrollDown">
            <summary>
            Represents a scroll down action.
            </summary>
        </member>
        <member name="F:EnDirectiveType.Custom">
            <summary>
            Represents a custom directive.
            </summary>
        </member>
        <member name="F:EnDirectiveType.Diagnostic">
            <summary>
            Represents a diagnostic directive (covers both Warning and Error).
            </summary>
        </member>
        <member name="F:EnDirectiveType.Line">
            <summary>
            Represents a line directive (covers hidden, default, and value).
            </summary>
        </member>
        <member name="F:EnDirectiveType.Region">
            <summary>
            Represents a region directive (also covers endregion).
            </summary>
        </member>
        <member name="F:EnDirectiveType.Include">
            <summary>
            Represents an include directive.
            </summary>
        </member>
        <member name="F:EnDirectiveType.Branching">
            <summary>
            Represents a branching directive.
            </summary>
        </member>
        <member name="F:EnDirectiveType.Definition">
            <summary>
            Represents a definition directive (for defining and undefining symbols).
            </summary>
        </member>
        <member name="F:EnDirectiveType.Pragma">
            <summary>
            Stores the full command as a List&lt;string&gt; because they are compiler-dependent.
            </summary>
        </member>
        <member name="P:DirectiveSelector.ToolSelection">
            <summary>
            The type of the preprocessor directive.
            </summary>
            <example>
            <code>
            #region MyRegion
            </code>
            Would be parsed as:
            <code>
            {
                "ToolSelection": "Region"
            }
            </code>
            </example>
        </member>
        <member name="T:EnOperatorType">
            <summary>
            Defines the possible types of operators.
            </summary>
        </member>
        <member name="F:EnOperatorType.Unary">
            <summary>
            Represents a unary operator (e.g., -, !).
            </summary>
        </member>
        <member name="F:EnOperatorType.Binary">
            <summary>
            Represents a binary operator (e.g., +, -, *, /).
            </summary>
        </member>
        <member name="F:EnOperatorType.Ternary">
            <summary>
            Represents a ternary operator (e.g., the conditional operator ?:)
            </summary>
        </member>
        <member name="P:OperatorSelector.OperatorType">
            <summary>
            The type of the operator.
            </summary>
            <example>
            <code>
            a + b
            </code>
            Would be parsed as:
            <code>
            {
                "OperatorType": "Binary"
            }
            </code>
            </example>
        </member>
        <member name="T:EnExpressionType">
            <summary>
            Defines the possible types of expressions.
            </summary>
        </member>
        <member name="F:EnExpressionType.ScrollDown">
            <summary>
            Represents a scroll down action.
            </summary>
        </member>
        <member name="F:EnExpressionType.LiteralValue">
            <summary>
            Represents a literal value expression.
            </summary>
        </member>
        <member name="F:EnExpressionType.VariableUse">
            <summary>
            Represents a variable use expression.
            </summary>
        </member>
        <member name="F:EnExpressionType.NewVariable">
            <summary>
            Represents a new variable expression.
            </summary>
        </member>
        <member name="F:EnExpressionType.CallableUse">
            <summary>
            Represents a callable use expression.
            </summary>
        </member>
        <member name="F:EnExpressionType.Bracket">
            <summary>
            Represents a bracket expression.
            </summary>
        </member>
        <member name="F:EnExpressionType.Lambda">
            <summary>
            Represents a lambda expression.
            </summary>
        </member>
        <member name="F:EnExpressionType.FormatString">
            <summary>
            Represents a format string expression.
            </summary>
        </member>
        <member name="F:EnExpressionType.Operator">
            <summary>
            Represents an operator expression selector.
            </summary>
        </member>
        <member name="F:EnExpressionType.Comprehension">
            <summary>
            Represents a comprehension expression.
            </summary>
        </member>
        <member name="P:ExpressionSelector.ToolSelection">
            <summary>
            The type of the expression.
            </summary>
            <example>
            <code>
            myVariable
            </code>
            Would be parsed as:
            <code>
            {
                "ToolSelection": "VariableUse"
            }
            </code>
            </example>
        </member>
        <member name="T:EnStatementType">
            <summary>
            Defines the possible types of statements.
            </summary>
        </member>
        <member name="F:EnStatementType.ScrollDown">
            <summary>
            Represents a scroll down action.
            </summary>
        </member>
        <member name="F:EnStatementType.Expression">
            <summary>
            Represents an expression statement.
            </summary>
        </member>
        <member name="F:EnStatementType.ControlFlow">
            <summary>
            Represents a control flow statement.
            </summary>
        </member>
        <member name="F:EnStatementType.ExceptionHandling">
            <summary>
            Represents an exception handling statement.
            </summary>
        </member>
        <member name="F:EnStatementType.Marking">
            <summary>
            Represents a marking statement.
            </summary>
        </member>
        <member name="F:EnStatementType.Looping">
            <summary>
            Represents a looping statement.
            </summary>
        </member>
        <member name="F:EnStatementType.Branching">
            <summary>
            Represents a branching statement.
            </summary>
        </member>
        <member name="F:EnStatementType.Import">
            <summary>
            Represents an import statement.
            </summary>
        </member>
        <member name="F:EnStatementType.Export">
            <summary>
            Represents an export statement.
            </summary>
        </member>
        <member name="F:EnStatementType.Custom">
            <summary>
            Represents a custom statement.
            </summary>
        </member>
        <member name="P:StatementSelector.ToolSelection">
            <summary>
            The type of the statement.
            </summary>
            <example>
            <code>
            return 0;
            </code>
            Would be parsed as:
            <code>
            {
                "ToolSelection": "ControlFlow"
            }
            </code>
            </example>
        </member>
        <member name="P:SummarizeAction.Message">
            <summary>
            Human-readable summary of what was changed.
            This should be a short, one-line description of the change.
            It should be in the past tense and should not include any
            information about the change itself.
            e.g. "Added mortgage calculation statement"
            </summary>
        </member>
        <member name="P:SourceChange.OldPath">
            <summary>
            The old path of the file that was changed if renamed
            </summary>
        </member>
        <member name="P:SourceChange.Path">
            <summary>
            The path of the file that was changed
            </summary>
        </member>
        <member name="P:SourceChange.PatchContent">
            <summary>
            The patch of the file that was changed
            </summary>
        </member>
        <member name="P:SourceChange.OriginalContent">
            <summary>
            The original content of the file that was changed
            </summary>
        </member>
        <member name="P:SourceChange.IsAdded">
            <summary>
            Whether the file was added
            </summary>
        </member>
        <member name="P:SourceChange.IsDeleted">
            <summary>
            Whether the file was deleted
            </summary>
        </member>
        <member name="P:SourceChange.IsCopied">
            <summary>
            Whether the file was copied
            </summary>
        </member>
        <member name="P:SourceChange.IsRenamed">
            <summary>
            Whether the file was renamed
            </summary>
        </member>
        <member name="P:SourceChange.IsOther">
            <summary>
            Whether another type of change was detected
            </summary>
        </member>
        <member name="P:LanguageEntry.Name">
            <summary>
            The language name.
            </summary>
        </member>
        <member name="P:LanguageEntry.Patterns">
            <summary>
            The language file path globbing patterns.
            </summary>
        </member>
        <member name="P:IOptionModel.Section">
            <summary>
            Gets the section name for the options model.
            </summary>
        </member>
        <member name="P:InferenceOptions.Section">
            <summary>
            The section name for the inference options.
            </summary>
        </member>
        <member name="P:InferenceOptions.Logging">
            <summary>
            Logging configuration for the inference options.
            </summary>
        </member>
        <member name="P:InferenceOptions.Configurations">
            <summary>
            The type of inference to use.
            </summary>
        </member>
        <member name="P:ModelOptions.Provider">
            <summary>
            The type of inference provider to use.
            </summary>
        </member>
        <member name="P:ModelOptions.Model">
            <summary>
            The model to use for inference.
            </summary>
        </member>
        <member name="P:ModelOptions.UseCache">
            <summary>
            Whether to use and store cached results.
            </summary>
        </member>
        <member name="P:ModelOptions.SamplingOptions">
            <summary>
            The options for inference.
            </summary>
        </member>
        <member name="P:ModelOptions.BaseUri">
            <summary>
            The URL of the API server.
            </summary>
        </member>
        <member name="P:ModelOptions.ApiKey">
            <summary>
            API key for the server.
            </summary>
        </member>
        <member name="T:SamplingOptions">
            <summary>
            Represents the sampling options for text generation.
            </summary>
        </member>
        <member name="P:SamplingOptions.NumContext">
            <summary>
            Number of tokens used for generating next token
            </summary>
        </member>
        <member name="P:SamplingOptions.Seed">
            <summary>
            Seed for random number generation.
            </summary>
        </member>
        <member name="P:SamplingOptions.Temperature">
            <summary>
            The temperature for sampling.
            </summary>
        </member>
        <member name="P:SamplingOptions.TopP">
            <summary>
            The top-p sampling parameter.
            </summary>
        </member>
        <member name="P:SamplingOptions.FrequencyPenalty">
            <summary>
            The frequency penalty for generated text.
            </summary>
        </member>
        <member name="P:SamplingOptions.PresencePenalty">
            <summary>
            The presence penalty for generated text.
            </summary>
        </member>
        <member name="P:LoggingOptions.RawMessageFolder">
            <summary>
            The path to the log file.
            </summary>
        </member>
        <member name="M:CommandInterceptor.Intercept(Spectre.Console.Cli.CommandContext,Spectre.Console.Cli.CommandSettings)">
            <param name="context">The command context.</param>
            <param name="settings">The command settings.</param>
        </member>
    </members>
</doc>
